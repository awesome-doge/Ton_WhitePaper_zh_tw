
# Telegram Open Network （TON） 中文版白皮書 v1.0 （修訂版）

作者：Dr. Nikolai Durov

譯者：吳泰、lucas3s、Inkiy、CryptoRose、Erica
版權所有：TON中國社區--tooz@toncommunity.org





## 摘要
本文主要目的是介紹Telegram Open Network（TON）和相關區塊鏈、點對點、分散式存儲和託管服務技術。篇幅有限，我們將重點關注TON平臺的獨特性和定義性特質，這對實現TON 的既定目標非常重要。

## 簡介
Telegram Open Newtwork（TON）是一個快速、安全且可擴展的區塊鏈和網路專案，在必要的情況下，它可達百萬級別TPS1，對普通使用者與服務供應商而言都是友好的。TON的目標是能夠容納當前已提出和構想中的所有應用。我們可以認為TON是一個巨大的分散式超級電腦，或者更確切地說是一個巨大的“超級伺服器”，旨在託管和提供各種服務。本文不構成各種實施細節的最終參考文獻。在開發和測試階段， 一些細節可能會發生變化。

2019年6月15日


---

1 TPS: Transactions Per Second，即伺服器每秒處理的事務數

---

- [Telegram Open Network （TON） 中文版白皮書 v1.0 （修訂版）](#telegram-open-network-ton-中文版白皮書-v10-修訂版)
  - [摘要](#摘要)
  - [簡介](#簡介)
  - [1	TON 概要](#1ton-概要)
  - [2	TON Blockchain](#2ton-blockchain)
    - [2.1	TON Blockchain作為2-Blockchains的集合及定義](#21ton-blockchain作為2-blockchains的集合及定義)
      - [2.1.1	TON 區塊鏈類型列表。包含以下這幾類區塊鏈：](#211ton-區塊鏈類型列表包含以下這幾類區塊鏈)
      - [2.1.2	無限分片範式（Infinite Sharding Paradigm）。](#212無限分片範式infinite-sharding-paradigm)
      - [2.1.3	消息/即時超立方體路由。](#213消息即時超立方體路由)
      - [2.1.4	主鏈、工作鏈和分片鏈的數量。](#214主鏈工作鏈和分片鏈的數量)
      - [2.1.5	工作鏈可以是虛擬區塊鏈，而不是真正的區塊鏈。](#215工作鏈可以是虛擬區塊鏈而不是真正的區塊鏈)
      - [2.1.6	工作鏈的識別。](#216工作鏈的識別)
      - [2.1.7	創建和啟動新的工作鏈。](#217創建和啟動新的工作鏈)
      - [2.1.8	鑒定分片鏈。](#218鑒定分片鏈)
      - [2.1.9	識別帳戶鏈。](#219識別帳戶鏈)
      - [2.1.10	分片鏈的動態拆分和合併（參照2.7）。](#2110分片鏈的動態拆分和合併參照27)
      - [2.1.11	基礎工作鏈或初始工作鏈（Workchain Zero）。](#2111基礎工作鏈或初始工作鏈workchain-zero)
      - [2.1.12	出塊時間。](#2112出塊時間)
      - [2.1.13	通過主鏈使工作鏈和分片鏈緊密耦合。](#2113通過主鏈使工作鏈和分片鏈緊密耦合)
      - [2.1.14	主鏈（Masterchain）區塊的雜湊作為一個全域狀態（global state）。](#2114主鏈masterchain區塊的雜湊作為一個全域狀態global-state)
      - [2.1.15	驗證人（Validators）生成新區塊；參照 2.6。](#2115驗證人validators生成新區塊參照-26)
      - [2.1.16	主鏈（masterchain）分叉。](#2116主鏈masterchain分叉)
      - [2.1.17	更正無效的分片鏈區塊。](#2117更正無效的分片鏈區塊)
      - [2.1.18	TON coins和多貨幣工作鏈（multi-currency workchains）。](#2118ton-coins和多貨幣工作鏈multi-currency-workchains)
      - [2.1.19	消息的傳遞與價值轉移。](#2119消息的傳遞與價值轉移)
      - [2.1.20	TON虛擬機器。](#2120ton虛擬機器)
      - [2.1.21	可配置的參數。](#2121可配置的參數)
    - [2.2	區塊鏈概述](#22區塊鏈概述)
      - [2.2.1	一般區塊鏈定義。](#221一般區塊鏈定義)
      - [2.2.2	TON區塊鏈的相關性。](#222ton區塊鏈的相關性)
      - [2.2.3	區塊鏈實例和區塊鏈類型。](#223區塊鏈實例和區塊鏈類型)
      - [2.2.3 依賴類型理論（Dependent type theory），互動式的定理證明器（Coq](#223-依賴類型理論dependent-type-theory互動式的定理證明器coq)
      - [2.2.5	類型語言（TL / Type Language）。](#225類型語言tl--type-language)
      - [2.2.6	區塊和交易作為狀態轉換運算子。](#226區塊和交易作為狀態轉換運算子)
      - [2.2.7	區塊序號（Block sequence numbers）。](#227區塊序號block-sequence-numbers)
      - [2.2.8	區塊雜湊值（Block hashes）。](#228區塊雜湊值block-hashes)
      - [2.2.9	雜湊假設（Hash assumption）。](#229雜湊假設hash-assumption)
      - [2.2.10	雜湊作用于TON區塊鏈。](#2210雜湊作用于ton區塊鏈)
    - [2.3	區塊鏈狀態、帳戶和雜湊表](#23區塊鏈狀態帳戶和雜湊表)
      - [2.3.1	帳戶 ID。](#231帳戶-id)
      - [2.3.2	主要組成部分：Hashmaps。](#232主要組成部分hashmaps)
      - [2.3.3	示例：TON帳戶餘額。](#233示例ton帳戶餘額)
      - [2.3.4	示例：智慧合約的永久存儲。](#234示例智慧合約的永久存儲)
      - [2.3.5	示例：永久存儲所有的智慧合約。](#235示例永久存儲所有的智慧合約)
      - [2.3.6	hashmap的類型。](#236hashmap的類型)
      - [2.3.7	把hashmap的類型當作Patricia樹。](#237把hashmap的類型當作patricia樹)
      - [2.3.8	Merkle-Patricia樹（MPT樹）。](#238merkle-patricia樹mpt樹)
      - [2.3.9	重新計算Merkle樹的雜湊值。](#239重新計算merkle樹的雜湊值)
      - [2.3.10	Merkle證明。](#2310merkle證明)
      - [2.3.11	對於諸如TON的多鏈系統，Merkle證明的重要性。](#2311對於諸如ton的多鏈系統merkle證明的重要性)
      - [2.3.12	TON VM的特點。](#2312ton-vm的特點)
      - [2.3.13	永久存儲TON智慧合約。](#2313永久存儲ton智慧合約)
      - [2.3.14	TVM單元。](#2314tvm單元)
      - [2.3.15	任意代數類型值的廣義Merkle證明。](#2315任意代數類型值的廣義merkle證明)
      - [2.3.16	支援TON VM資料結構中的分片。](#2316支援ton-vm資料結構中的分片)
      - [2.3.17	為永久存儲支付。](#2317為永久存儲支付)
      - [2.3.18	本地和全域智能合約；智慧合約實例。](#2318本地和全域智能合約智慧合約實例)
      - [2.3.19	限制智慧合約的分割。](#2319限制智慧合約的分割)
      - [2.3.20	帳戶 / 智慧合約狀態。](#2320帳戶--智慧合約狀態)
    - [2.4	分片鏈之間的通信](#24分片鏈之間的通信)
      - [2.4.1	消息，帳戶和交易：系統的一種鳥瞰視角下的。](#241消息帳戶和交易系統的一種鳥瞰視角下的)
      - [2.4.2	作為流程或參與者的帳戶；Actor 模型。](#242作為流程或參與者的帳戶actor-模型)
      - [2.4.3	消息接收者。](#243消息接收者)
      - [2.4.4	消息發送者。](#244消息發送者)
      - [2.4.5	消息值。](#245消息值)
      - [2.4.6	“來源不明的消息（messages from nowhere）”。](#246來源不明的消息messages-from-nowhere)
      - [2.4.7	日誌（Log）消息，或 “去向不定的消息（messages to nowhere）”。](#247日誌log消息或-去向不定的消息messages-to-nowhere)
      - [2.4.8	與鏈下服務和外部區塊鏈互動。](#248與鏈下服務和外部區塊鏈互動)
      - [2.4.9	訊息文字。](#249訊息文字)
      - [2.4.10	Gas 限制和其他工作鏈 / VM 特定參數。](#2410gas-限制和其他工作鏈--vm-特定參數)
      - [2.4.11	創建消息：智慧合約和交易。](#2411創建消息智慧合約和交易)
      - [2.4.12	傳遞資訊。](#2412傳遞資訊)
      - [2.4.13	消息的傳遞是一種交易。](#2413消息的傳遞是一種交易)
      - [2.4.14	同一智慧合約實例之間的消息。](#2414同一智慧合約實例之間的消息)
      - [2.4.15	發送給智慧合約任何實例的消息；萬用字元地址。](#2415發送給智慧合約任何實例的消息萬用字元地址)
      - [2.4.16	輸入佇列不存在。](#2416輸入佇列不存在)
      - [2.4.17	輸出佇列。](#2417輸出佇列)
      - [2.4.18	可靠，快速的鏈間消息傳遞。](#2418可靠快速的鏈間消息傳遞)
      - [2.4.19	超立方體路由（Hypercube routing slow path”。](#2419超立方體路由hypercube-routing-slow-path)
      - [2.4.20	“快速路徑（fast path）”。](#2420快速路徑fast-path)
      - [2.4.21	從相鄰分片鏈的輸出佇列收集輸入消息。](#2421從相鄰分片鏈的輸出佇列收集輸入消息)
      - [2.4.22	從輸出佇列中刪除消息。](#2422從輸出佇列中刪除消息)
      - [2.4.23	防止雙重傳遞消息。](#2423防止雙重傳遞消息)
      - [2.4.24	轉發用於其他分片鏈的消息。](#2424轉發用於其他分片鏈的消息)
      - [2.4.25	為轉發和保留消息支付。](#2425為轉發和保留消息支付)
      - [2.4.26	來自主鏈的消息。](#2426來自主鏈的消息)
      - [2.4.27	同一個分片鏈中的帳戶之間的消息。](#2427同一個分片鏈中的帳戶之間的消息)
    - [2.5	分片鏈的全域狀態。 “Bag of Cells”](#25分片鏈的全域狀態-bag-of-cells)
      - [2.5.1	分片鏈狀態作為帳戶鏈狀態的集合。](#251分片鏈狀態作為帳戶鏈狀態的集合)
      - [2.5.2	拆分和合併分片鏈狀態。](#252拆分和合併分片鏈狀態)
      - [2.5.3	帳戶鏈狀態。](#253帳戶鏈狀態)
      - [2.5.4	全域工作鏈狀態。](#254全域工作鏈狀態)
      - [2.5.5	Low-level （低級）來看：“Bag of Cells”。](#255low-level-低級來看bag-of-cells)
      - [2.5.6	分片鏈的區塊作為 “Bag of Cells”。](#256分片鏈的區塊作為-bag-of-cells)
      - [2.5.7	“Bag of Cells” 的對象。](#257bag-of-cells-的對象)
      - [2.5.8	更新帳戶狀態。](#258更新帳戶狀態)
      - [2.5.9	區塊的更新](#259區塊的更新)
      - [2.5.10	Merkle 證明作為 “Bag of Cells”。](#2510merkle-證明作為-bag-of-cells)
      - [2.5.11	Merkle 證明作為全節點的回應。](#2511merkle-證明作為全節點的回應)
      - [2.5.12	用 Merkle 有效證明增強更新和狀態更新。](#2512用-merkle-有效證明增強更新和狀態更新)
      - [2.5.13	分片鏈區塊中的帳戶狀態更新。](#2513分片鏈區塊中的帳戶狀態更新)
      - [2.5.14	“Bag of Cells”](#2514bag-of-cells)
      - [2.5.15	TON 區塊鏈的區塊“頭（header）”。](#2515ton-區塊鏈的區塊頭header)
    - [2.6	創建和驗證新的區塊。](#26創建和驗證新的區塊)
      - [2.6.1	驗證人（Validator）。](#261驗證人validator)
      - [2.6.2	驗證人（Validator）代替礦工（Miner）。](#262驗證人validator代替礦工miner)
      - [2.6.3	提名人（Nominator）和 “mining pools（礦池）”](#263提名人nominator和-mining-pools礦池)
      - [2.6.4	漁夫（Fisherman）：通過指出別人的錯誤來獲得金錢。](#264漁夫fisherman通過指出別人的錯誤來獲得金錢)
      - [2.6.5	校對人（Collator）：通過給驗證人提供出新區塊的建議來獲得金錢。](#265校對人collator通過給驗證人提供出新區塊的建議來獲得金錢)
      - [2.6.6	校對人或驗證人：從説明使用者整合交易中獲取金錢。](#266校對人或驗證人從説明使用者整合交易中獲取金錢)
      - [2.6.7	選舉全域驗證人人。](#267選舉全域驗證人人)
      - [2.6.8	“任務組（task groups）”。](#268任務組task-groups)
      - [2.6.9	在每個任務組上輪換優先順序順序。](#269在每個任務組上輪換優先順序順序)
      - [2.6.10	分片鏈候選區塊的傳播。](#2610分片鏈候選區塊的傳播)
      - [2.6.11	驗證候選區塊。](#2611驗證候選區塊)
      - [2.6.12	選舉下一個候選區塊。](#2612選舉下一個候選區塊)
      - [2.6.13	驗證人必須保留它們簽名過的區塊。](#2613驗證人必須保留它們簽名過的區塊)
      - [2.6.14	將新分片鏈區塊的塊頭和簽名傳播到所有驗證人。](#2614將新分片鏈區塊的塊頭和簽名傳播到所有驗證人)
      - [2.6.15	主鏈生成新的區塊。](#2615主鏈生成新的區塊)
      - [2.6.16	驗證人必須同步主鏈的狀態。](#2616驗證人必須同步主鏈的狀態)
      - [2.6.17	分片鏈的區塊是並行生成和傳播的。](#2617分片鏈的區塊是並行生成和傳播的)
      - [2.6.18	區塊保留攻擊的緩解。](#2618區塊保留攻擊的緩解)
      - [2.6.19	主鏈區塊比分片鏈區塊生成更晚。](#2619主鏈區塊比分片鏈區塊生成更晚)
      - [2.6.20	慢的驗證人可能收到較低的獎勵。](#2620慢的驗證人可能收到較低的獎勵)
      - [2.6.21	“深度（Depth）”。](#2621深度depth)
      - [2.6.22	驗證人負責簽名的分片鏈區塊的相對有效性；絕對有效性如下。](#2622驗證人負責簽名的分片鏈區塊的相對有效性絕對有效性如下)
      - [2.6.23	簽名主鏈的區塊。](#2623簽名主鏈的區塊)
      - [2.6.24	驗證人的總量。](#2624驗證人的總量)
      - [2.6.25	去中心化的系統。](#2625去中心化的系統)
      - [2.6.26	區塊的相對可靠性。](#2626區塊的相對可靠性)
      - [2.6.27	“強化（Strengthening）” 區塊鏈](#2627強化strengthening-區塊鏈)
      - [2.6.28	區塊的遞迴可靠性。](#2628區塊的遞迴可靠性)
      - [2.6.29	POS 的結果。](#2629pos-的結果)
    - [2.7	拆分和合併分片鏈](#27拆分和合併分片鏈)
      - [2.7.1 分片配置](#271-分片配置)
      - [2.7.2 最新的分片配置和狀態](#272-最新的分片配置和狀態)
      - [2.7.3 宣布並執行分片配置和更改](#273-宣布並執行分片配置和更改)
      - [2.7.4 新分片鏈的驗證人任務組](#274-新分片鏈的驗證人任務組)
      - [2.7.5	原任務組工作期間限制拆分/合併的操作](#275原任務組工作期間限制拆分合併的操作)
      - [2.7.6 確定拆分操作的必要性](#276-確定拆分操作的必要性)
      - [2.7.7 執行災分操作](#277-執行災分操作)
      - [2.7.8 確定合併操作的必要性。](#278-確定合併操作的必要性)
      - [2.7.9](#279)
    - [2.8	區塊鏈專案的分類](#28區塊鏈專案的分類)
      - [2.8.1	區塊鏈專案的分類](#281區塊鏈專案的分類)
      - [2.8.2	單鏈和多鏈項目](#282單鏈和多鏈項目)
      - [2.8.3	創建和驗證區塊：工作量證明與權益證明](#283創建和驗證區塊工作量證明與權益證明)
      - [2.8.4	POS 的演變：DPOS vs BFT](#284pos-的演變dpos-vs-bft)
      - [2.8.5	DPOS](#285dpos)
      - [2.8.6	支援交易裡的圖靈完備代碼，即允許執行任意智能合約](#286支援交易裡的圖靈完備代碼即允許執行任意智能合約)
      - [2.8.7	多鏈系統的分類](#287多鏈系統的分類)
      - [2.8.8	區塊鏈類型：同構與異構系統](#288區塊鏈類型同構與異構系統)
      - [2.8.9	同構-異構混合系統](#289同構-異構混合系統)
      - [2.8.10	若干工作鏈的異構系統具有相同的規則，聯盟鏈](#2810若干工作鏈的異構系統具有相同的規則聯盟鏈)
      - [2.8.11	內部或外部存在主鏈](#2811內部或外部存在主鏈)
      - [2.8.12	分片支援](#2812分片支援)
      - [2.8.13	動態和靜態分片](#2813動態和靜態分片)
      - [2.8.14	區塊鏈之間的相互作用：鬆散耦合系統和緊密耦合系統](#2814區塊鏈之間的相互作用鬆散耦合系統和緊密耦合系統)
      - [2.8.15	簡化分類，幾代區塊鏈專案](#2815簡化分類幾代區塊鏈專案)
      - [2.8.16	改變區塊鏈項目 “基因（genome）” 的複雜性](#2816改變區塊鏈項目-基因genome-的複雜性)
      - [2.8.17	TON 區塊鏈的 “基因（genome）”](#2817ton-區塊鏈的-基因genome)
    - [2.9	與其他區塊鏈項目的比較](#29與其他區塊鏈項目的比較)
      - [2.9.1	比特幣（Bitcoin）[12]；https://bitcoin.org/。](#291比特幣bitcoin12httpsbitcoinorg)
      - [2.9.2	乙太坊（Ethereum）[2] ；https://ethereum.org/。](#292乙太坊ethereum2-httpsethereumorg)
      - [2.9.3	未來幣（NXT）； https://nxtplatform.org/。](#293未來幣nxt-httpsnxtplatformorg)
      - [2.9.4	Tezos；https://www.tezos.com/。](#294tezoshttpswwwtezoscom)
      - [2.9.5	Casper 31](#295casper-31)
      - [2.9.6	比特股（BitShares）[8]；https://bitshares.org。](#296比特股bitshares8httpsbitsharesorg)
      - [2.9.7	EOS[5]；https://eos.io。](#297eos5httpseosio)
      - [2.9.8	波卡（Polkadot） https://polkadot.io/。](#298波卡polkadot-httpspolkadotio)
      - [2.9.9	Universa https://universa.io。](#299universa-httpsuniversaio)
      - [2.9.10	Plasma https://plasma.io。](#2910plasma-httpsplasmaio)
      - [2.9.11	專用區塊鏈項目](#2911專用區塊鏈項目)
      - [2.9.12	TON區塊鏈](#2912ton區塊鏈)
      - [2.9.13	“讓 Facebook 上鏈”？](#2913讓-facebook-上鏈)
  - [3	TON網路](#3ton網路)
      - [3.1	抽象資料包表網路層（簡稱 ADNL）](#31抽象資料包表網路層簡稱-adnl)
      - [3.1.1	抽象網路位址。](#311抽象網路位址)
      - [3.1.2	較低級別的網路。UDP的實現。](#312較低級別的網路udp的實現)
      - [3.1.3	基於UDP最簡單的ADNL的例子。](#313基於udp最簡單的adnl的例子)
      - [3.1.4	寄件者的明文位址是一種安全性較低的方式。](#314寄件者的明文位址是一種安全性較低的方式)
      - [3.1.5	通道和通道識別字。](#315通道和通道識別字)
      - [3.1.6	通道作為一種隧道識別字。](#316通道作為一種隧道識別字)
      - [3.1.7	零通道和bootstrap問題。](#317零通道和bootstrap問題)
      - [3.1.8	ADNL上類似TCP的流協議。](#318adnl上類似tcp的流協議)
      - [3.1.9	RLDP或ADNL上的可靠大資料包表協議。](#319rldp或adnl上的可靠大資料包表協議)
    - [3.2	TON DHT：類似Kademlia的分散式雜湊表](#32ton-dht類似kademlia的分散式雜湊表)
      - [3.2.1	TON DHT的金鑰。](#321ton-dht的金鑰)
      - [3.2.2	DHT的值。](#322dht的值)
      - [3.2.3	DHT的節點。半永久性網路身份。](#323dht的節點半永久性網路身份)
      - [3.2.4	Kademlia距離。](#324kademlia距離)
      - [3.2.5	類似Kademlia的DHTs和TON DHT。](#325類似kademlia的dhts和ton-dht)
      - [3.2.6	Kademli路由表。](#326kademli路由表)
      - [3.2.7	（Kademlia網路查詢。）Kademlia節點通常支援以下網路查詢：](#327kademlia網路查詢kademlia節點通常支援以下網路查詢)
      - [3.2.8	啟動Kademlia節點。](#328啟動kademlia節點)
      - [3.2.9	在TON DHT中存儲值。](#329在ton-dht中存儲值)
      - [3.2.10	TON DHT中的分散式 “流追蹤器”](#3210ton-dht中的分散式-流追蹤器)
      - [3.2.11	Fall-back keys](#3211fall-back-keys)
      - [3.2.12	定位服務。](#3212定位服務)
      - [3.2.13	定位TON區塊鏈帳戶的所有者。](#3213定位ton區塊鏈帳戶的所有者)
      - [3.2.14	找到抽象地址的位置。](#3214找到抽象地址的位置)
    - [3.3	覆蓋網路（Overlay Networks） Multicasting Messages）](#33覆蓋網路overlay-networks-multicasting-messages)
      - [3.3.1	覆蓋網路。](#331覆蓋網路)
      - [3.3.2	TON中的覆蓋網路。](#332ton中的覆蓋網路)
      - [3.3.3	私人和公共覆蓋網路。](#333私人和公共覆蓋網路)
      - [3.3.4	中心化控制的覆蓋網路。](#334中心化控制的覆蓋網路)
      - [3.3.5	加入覆蓋網路。](#335加入覆蓋網路)
      - [3.3.6	找到覆蓋網路的一個成員的位置。](#336找到覆蓋網路的一個成員的位置)
      - [3.3.7	找到覆蓋網路的更多成員。創建連結。](#337找到覆蓋網路的更多成員創建連結)
      - [3.3.8	維護相鄰節點列表。](#338維護相鄰節點列表)
      - [3.3.9	覆蓋網路是一個隨機子圖。](#339覆蓋網路是一個隨機子圖)
      - [3.3.10	TON覆蓋網路經過優化，可降低延遲。](#3310ton覆蓋網路經過優化可降低延遲)
      - [3.3.11	覆蓋網路中的gossip協定。](#3311覆蓋網路中的gossip協定)
      - [3.3.12	覆蓋網路作為廣播域。](#3312覆蓋網路作為廣播域)
      - [3.3.13	更複雜的廣播協議。](#3313更複雜的廣播協議)
      - [3.3.14	檢查覆蓋網路的連線性。](#3314檢查覆蓋網路的連線性)
      - [3.3.15	流媒體廣播協議。](#3315流媒體廣播協議)
      - [3.3.16	基於現有的覆蓋網路構建新的覆蓋網路。](#3316基於現有的覆蓋網路構建新的覆蓋網路)
      - [3.3.17	帶有覆蓋網路的覆蓋網路。](#3317帶有覆蓋網路的覆蓋網路)
  - [4	TON 服務和應用](#4ton-服務和應用)
    - [4.1	TON](#41ton)
      - [4.1.1	應用和服務。](#411應用和服務)
      - [4.1.2	應用的位置：鏈上，鏈下或混合。](#412應用的位置鏈上鏈下或混合)
      - [4.1.3	中心化：中心化的和去中心化的或分散式應用程式。](#413中心化中心化的和去中心化的或分散式應用程式)
      - [4.1.4](#414)
      - [4.1.2 中提到的一種可能的方法是在 TON Blockchain中完全部署 “分散式應用程式”（通常簡稱](#412-中提到的一種可能的方法是在-ton-blockchain中完全部署-分散式應用程式通常簡稱)
      - [4.1.5	純粹的網路服務：“ton-sites”](#415純粹的網路服務ton-sites)
      - [4.1.6	Telegram Messenger 作為 ton-service；MTProto](#416telegram-messenger-作為-ton-servicemtproto)
      - [4.1.7	混合服務：部分鏈下，部分鏈上。](#417混合服務部分鏈下部分鏈上)
      - [4.1.8	示例：保持文件在鏈下；TON Storage。](#418示例保持文件在鏈下ton-storage)
      - [4.1.9	“霧服務”。](#419霧服務)
      - [4.1.10	“霧計算（fog computing）” 平臺作為分散的混合服務。](#4110霧計算fog-computing-平臺作為分散的混合服務)
      - [4.1.11	示例：TON Proxy 是霧服務。](#4111示例ton-proxy-是霧服務)
      - [4.1.12	示例：TON Payments 是一項霧服務。](#4112示例ton-payments-是一項霧服務)
    - [4.2	連接用戶和服務提供者](#42連接用戶和服務提供者)
      - [4.2.1	示例：連接到 TON Payments。](#421示例連接到-ton-payments)
      - [4.2.2	TON Storage。](#422ton-storage)
      - [4.2.3	鏈上，混合和鏈下註冊管理機構。](#423鏈上混合和鏈下註冊管理機構)
      - [4.2.4	在一個側鏈上的註冊或交易。](#424在一個側鏈上的註冊或交易)
      - [4.2.5	工作鏈中的註冊表或交易。](#425工作鏈中的註冊表或交易)
    - [4.3	訪問 TON Services](#43訪問-ton-services)
      - [4.3.1	TON DNS：主要是鏈上分層功能變數名稱服務。](#431ton-dns主要是鏈上分層功能變數名稱服務)
      - [4.3.2	TON DNS 用例。](#432ton-dns-用例)
      - [4.3.3	TON DNS 智能合約。](#433ton-dns-智能合約)
      - [4.3.4	DNS 雜湊圖或 TON DNS 記錄的值。](#434dns-雜湊圖或-ton-dns-記錄的值)
      - [4.3.5	註冊現有域的新子域。](#435註冊現有域的新子域)
      - [4.3.6	DNS 智慧合約中檢索資料。](#436dns-智慧合約中檢索資料)
      - [4.3.7	TON DNS 域。](#437ton-dns-域)
      - [4.3.8	為輕節點翻譯 TON DNS 功能變數名稱。](#438為輕節點翻譯-ton-dns-功能變數名稱)
      - [4.3.9	專用的 “TON DNS servers”。](#439專用的-ton-dns-servers)
      - [4.3.10	訪問智慧合約中保存的資料。](#4310訪問智慧合約中保存的資料)
      - [4.3.11	“Get methods”。](#4311get-methods)
      - [4.3.12	智能合約“Get methods”的嘗試性執行。](#4312智能合約get-methods的嘗試性執行)
      - [4.3.13	TL-schemes中的智慧合約介面。](#4313tl-schemes中的智慧合約介面)
      - [4.3.14	智慧合約的公共介面。](#4314智慧合約的公共介面)
      - [4.3.15	智慧合約的使用者介面。](#4315智慧合約的使用者介面)
      - [4.3.16	ton-service 的使用者介面。](#4316ton-service-的使用者介面)
      - [4.3.17	TON DNS 定位使用者介面。](#4317ton-dns-定位使用者介面)
      - [4.3.18	模糊鏈上和鏈下服務之間的區別。](#4318模糊鏈上和鏈下服務之間的區別)
      - [4.3.19](#4319)
      - [4.3.20	“ton-sites”](#4320ton-sites)
      - [4.3.21	超連結（Hyperlinks）。](#4321超連結hyperlinks)
      - [4.3.22	URL 可以指定一些參數。](#4322url-可以指定一些參數)
      - [4.3.23	POST 動作。](#4323post-動作)
      - [4.3.24	TON WWW。](#4324ton-www)
      - [4.3.25	TON WWW 的優點。](#4325ton-www-的優點)
      - [5	TON Payments](#5ton-payments)
    - [5.1 支付通道](#51-支付通道)
      - [5.1.1 支付通道的思路](#511-支付通道的思路)
      - [5.1.2 無需信任的支付通道](#512-無需信任的支付通道)
      - [5.1.3 簡單、雙向同步的無需信任支付通道](#513-簡單雙向同步的無需信任支付通道)
      - [5.1.4	同步支付通道，一個帶有兩個驗證人的簡單的虛擬區塊鏈](#514同步支付通道一個帶有兩個驗證人的簡單的虛擬區塊鏈)
      - [5.1.5	非同步支付通道，具有兩個工作鏈的虛擬區塊鏈](#515非同步支付通道具有兩個工作鏈的虛擬區塊鏈)
      - [5.1.6 單向支付通道](#516-單向支付通道)
      - [5.1.7 更複雜的支付通道，授權](#517-更複雜的支付通道授權)
      - [5.1.8	複雜的支付通道智慧合約面臨的挑戰](#518複雜的支付通道智慧合約面臨的挑戰)
      - [5.1.9	TON VM	“智能”](#519ton-vm智能)
      - [5.1.10	智慧支付通道內的簡單支付通道](#5110智慧支付通道內的簡單支付通道)
    - [5.2	“閃電網路”](#52閃電網路)
      - [5.2.1 支付通道的限制](#521-支付通道的限制)
      - [5.2.2	支付通道 或 “閃電網路”](#522支付通道-或-閃電網路)
      - [5.2.3 支付通道網路概述](#523-支付通道網路概述)
      - [5.2.4 區塊鏈資金轉帳](#524-區塊鏈資金轉帳)
      - [5.2.5 支付通道鏈中的虛擬支付通道](#525-支付通道鏈中的虛擬支付通道)
      - [5.2.6 尋找閃電網路中的路徑](#526-尋找閃電網路中的路徑)
      - [5.2.7 優化](#527-優化)
      - [5.2.8 結論](#528-結論)

## 1	TON 概要
Telegram Open Network（TON）由以下幾個元件組成：

●	靈活的多鏈平臺（TON Blockchain或稱TON區塊鏈；參見第 2 章），能夠達到百萬級別 TPS，帶有圖靈完備智慧合約、可升級的正式區塊鏈規範、多類型加密貨幣價值交換，支援小額支付通道和鏈下支付網路。TON區塊鏈提出了一些新穎和獨特的功能， 例如 “自我修復”的垂直區塊鏈機制（參見 2.1.17）和即時超立方體路由（Instant Hypercube Routing;參見 2.4.20），使其同時兼具快速、可靠、可擴展和一致性的特性。

●	點對點網路（TON P2P Network，或稱TON Network，亦稱TON網路；參見第 3 章）
，不僅可以用於訪問TON區塊鏈、發送交易申請，以及接收使用者感興趣的區塊鏈更新內容（例如與客戶帳戶或智慧合約相關的更新），也可以支援任意分散式服務，無論服務是否與區塊鏈相關。

●	分散式檔存儲技術（TON Storage或稱TON 存儲技術；參見 4.1.8），可通過 TON 網路進行訪問，被 TON 區塊鏈用於存儲區塊和狀態資料（快照）的存檔副本，還可以通過類似流（Torrent）的訪問技術，為使用者儲存任意檔，或是儲存運行於平臺的其他服務專案。

●	網路代理/ 匿名層（TON Proxy或稱TON代理；參見 4.1.11 和 3.1.6），類似於I2P（ Invisible Internet Project；隱形網路計畫），用於在必要時隱藏TON網路節點的身份和IP位址（例如包含大量加密貨幣的帳戶進行交易所用的節點，或者高額質押的區塊鏈驗證人節點，後者希望隱藏其確切的 IP 地址和地理位置，防止 DDoS 攻擊）。

●	類似Kademlia的分散式雜湊表（TON DHT；參見 3.2），用作TON存儲的 “流追蹤器”
（torrent tracker；參見 3.2.10）或者用作TON 代理的 “輸入通道定位器”（input tunnel locator；參見 3.2.14 ），並作為 TON 服務的服務定位器（參見 3.2.12）。

●	支援任意服務的平臺（TON Services或稱TON服務；參見第 4 章），內置於TON 網
絡和 TON 代理，並通過 TON 網路和 TON 代理訪問，帶有形式化介面 （參見 4.3.14
），驅動著類似流覽器或智慧手機應用程式之間交互。這些形式化介面和永久性服務入口點可以發佈在TON區塊鏈上（參見 4.3.17）；從資訊發佈在TON區塊鏈上開始， 實際節點在任意時刻提供的服務都可以通過TON DHT查找（參見 3.2.12）。服務可以通過在TON區塊鏈中創建智慧合約的方式向客戶進行保證（參見 4.1.7）。

●	TON DNS（參見 4.3.1），一種服務，用於為帳戶、智慧合約、服務和網路節點分配可讀性強的名稱。

●	TON Payments（參見第 5 章），小額支付、小額支付通道和小額支付通道網路的平臺。它可用於快速的鏈下價值交換，也可用於支付由 TON Services 支援的服務。
 
●	TON 將允許與協力廠商的通信和社交網路應用進行簡易集成，從而使區塊鏈技術和分散式服務普及到普通使用者（參見 4.3.24），而不僅僅供少數早期的加密貨幣持有者使用。我們將在另一個項目Telegram Messenger中提供這種集成的示例（參見 4.3.19
）。


雖然 TON Blockchain是TON Project的核心，而其他元件可能被視為TON Blockchain的支持角色，但它們本身就具有有用且有趣的功能。結合起來，它們允許平臺承載更多樣化的應用程式，而不僅僅靠TON Blockchain來實現（參見 2.9.13 和 4.1）。


## 2	TON Blockchain
我們首先介紹Telegram Open Network（TON）區塊鏈，這是項目的核心組成部分。白皮書打算“自上而下”：首先給出整體項目的描述，然後提供每個元件的更多細節。
為簡單起見，我們在這裡談論TON Blockchain，儘管原則上該區塊鏈協定的幾個實例可以獨立運行。

### 2.1	TON Blockchain作為2-Blockchains的集合及定義
TON Blockchain實際上是區塊鏈的集合（甚至是“區塊鏈中的區塊鏈”的集合，或者說是“二維區塊鏈”（2-blockchains）——這一概念將在後面的 2.1.17 中闡明），因為沒有哪個單一的區塊鏈專案可以實現百萬 TPS 交易輸送量，對比而言，單鏈區塊鏈僅能達到每秒數十次的交易速度。

#### 2.1.1	TON 區塊鏈類型列表。包含以下這幾類區塊鏈：

●	獨特的master blockchain，或簡稱主鏈（masterchain），用來存儲一些基礎資訊，這
些資訊包括協定、參數的當前價值；驗證人和它們的抵押記錄組；當前活躍的工作鏈
（workchains）和它們的 “分片”（shards）組；及最重要的是所有工作鏈（ workchains）和分片鏈（shardchains）裡的最近生成的雜湊值組。

•	多個working blockchains（最多可達232），或簡稱工作鏈（workchains），是名副其實的“苦力”，功能包含價值交換和智慧合約。不同的工作鏈有不同的“規則”，意味著不同的帳戶位址格式、不同的交易格式，不同的虛擬機器（VMs）用於智慧合約， 甚至是不同的工作鏈由不同的加密貨幣來處理交易等。但它們都必須滿足統一的互通性標準，以便使不同工作鏈之間的交互成為可能且相對簡單。在這點而言， TON Blockchain是異構的（參見 2.8.8），類似於 EOS（參見 2.9.7）和 Polkadot
（參見 2.9.8）。

•	每個工作鏈（workchains）又依次被細分為最多260次方個分片鏈（shard blockchains；或簡稱為shardchains），分片鏈與工作鏈的生成規則和區塊結構相同
，一個分片鏈負責一種類型的帳戶子集，具體取決於其帳戶位址的頭幾個位元組（這些是最重要的）。換句話說，分片的形式植入系統中的（參見 2.8.12）。因為所有
 
這些分片鏈具有統一的生成規則和區塊結構，這樣說來所以 TON 區塊鏈是同構的
（參見 2.8.8），這也與之前乙太坊的的一個擴容方案2中提及的類似。

•	分片鏈上的每個區塊（其實主鏈上也是）不僅僅只是一個區塊，它可能是一個小型區塊鏈。通常情況下，這種 “區塊的區塊鏈” 或者 “垂直區塊鏈” 都只包含一個塊，然後我們可能會認為這只是分片鏈的相應區塊（在這種情況下也稱為 “水準區塊
鏈”）。但是，如果有必要修復不正確的分片鏈區塊，則會將新區塊提交到 “垂直區塊鏈” 中，其中包含無效 “水準區塊鏈” 區塊的替換品或者 “區塊的不同性”，包含此區塊先前版本部分內容的僅有描述也需要修改。這是一種特定於TON的機制，用於替換檢測到的無效區塊，而不會涉及所有分片鏈的分叉問題；它將在 2.1.17 中更詳細地解釋。現在，我們只是說每個分片鏈（和主鏈）不是傳統的區塊鏈，而是鏈中鏈或區塊鏈中的區塊鏈，或者只是一個二維區塊鏈（2D-blockchain或2-blockchain）。

#### 2.1.2	無限分片範式（Infinite Sharding Paradigm）。
幾乎所有的區塊鏈分片提議都是 “自上而下” 的：首先我們想像一個單鏈區塊鏈，然後討論如何將其拆分成幾個交互的分片鏈，以提高性能並實現可擴展性。
TON 的分片方法是 “自下而上”，解釋如下。

想像一下，分片已經發揮到極限，因此每個分片鏈中只保留一個帳戶或智慧合約。然後我們有大量的 “帳戶鏈（account- chains）”，每個帳戶鏈描述唯一一個帳戶的狀態和狀態過渡，並相互發送價值承載資訊以傳輸價值和資訊。

當然，想要擁有數以億計的區塊鏈是不切實際的，並且每個區塊鏈通常很少出現更新（即新區塊）。為了更有效地實現它們，我們將這些 “帳戶鏈（account- chains）” 分組為 “分片鏈（ shardchains）”，以便分片鏈的每個區塊基本上都是已分配給此分片的帳戶鏈區塊的集合。因此，“帳戶鏈” 在 “分片鏈” 中僅以純粹的虛擬或邏輯形式存在。

我們將這種觀點稱為無限分片範式。它解釋了TON區塊鏈的許多設計初衷。

#### 2.1.3	消息/即時超立方體路由。
即時超立方體路由（Instant Hypercube Routing）。無限分片範式（Sharding Paradigm）引導我們將每個帳戶（或智慧合約）視為自己的分片鏈。那麼，A帳戶可能影響B帳戶狀態的唯一方法就是向它發送一條消息（這是所謂的Actor模型的特殊實例，帶有Actors帳戶；參見2.4.2）。因此，帳戶之間的消息系統（和分片鏈，因為從一般意義上說來源和目標帳戶通常在不同的分片鏈中）對於可擴展系統至關重要，如TON區塊鏈。實際上，TON區塊鏈的這個新功能，我們稱其為即時超立方體路由（Instant Hypercube Routing；參見 2.4.20），使其能夠將一個分片鏈區塊中創建的消息傳遞和處理至目標分片鏈的下一個區塊中，而不用管系統中分片鏈的總數。

#### 2.1.4	主鏈、工作鏈和分片鏈的數量。
TON區塊鏈只有一個主鏈。但該系統最多可容納232個工作鏈，每個工作鏈最多可細分成260個分片鏈。

---

2 https://github.com/ethereum/wiki/wiki/Sharding-FAQ

---

#### 2.1.5	工作鏈可以是虛擬區塊鏈，而不是真正的區塊鏈。
因為工作鏈通常被細分為分片鏈，所以工作鏈的存在是“虛擬的”，而不是真正的區塊鏈，這意味著它不是後文2.2.1所述的一般意義上的真正區塊鏈，而只是一個分片鏈的集合。當只有一個分片鏈對應一個工作鏈時，這個唯一的分片鏈可能可以用工作鏈來識別，在這種情況下，工作鏈成為“真正的”區塊鏈，至少在一段時間內，它與常規的單鏈區塊鏈的設計有一定相似性。然而無限分片範式（參見 2.1.2）告訴我們，這種相似性只是表面：重要的是潛在大量的“帳戶鏈（account- chains）”可以暫時歸類到一個區塊鏈中。

#### 2.1.6	工作鏈的識別。
每個工作鏈都有序號或工作鏈的專屬識別字（workchain_id：uint32），這是一個無符號的32 位元整數。工作鏈由主鏈中的特殊交易創建，定義（先前未使用過的）工作鏈的識別字和工作鏈的正式描述，至少足以使這個工作鏈與其他工作鏈交互，並對這個工作鏈的區塊進行表面驗 證。

#### 2.1.7	創建和啟動新的工作鏈。
基本上任何社區成員都可以創建新的工作鏈，只需支付發佈新工作鏈所需的（高）主鏈交易費用，這些費用是用於發佈新工作鏈的正式規範。但為了使新的工作鏈更積極，它需要得到三分之二驗證人的共識，因為他們也需要升級軟體來處理新工作鏈的區塊，並通過主鏈的特殊交易來表明它們已經准好用新的工作鏈了。對啟動新工作鏈感興趣的一方可能會為驗證人提供一些激勵，通過智慧合約分發的一些獎勵來支持新的工作鏈。

#### 2.1.8	鑒定分片鏈。
每個 shardchain 由一對（w,s）=（workchain_id,shard_prefix）標識，其中 workchain_id：
uint 標識相應的工作鏈，shard_prefix：20...60是一個長度最多為2的60次方的字串，來定義
32
此分片鏈負責的帳戶子集。即，所有具有以 shard_prefix 開頭的 account_id 的帳戶（即
shard_prefix 作為最高有效位）將被分配給該分片鏈。

#### 2.1.9	識別帳戶鏈。
回想一下，“帳戶鏈（account- chains）”只是虛擬存在的（參見2.1.2）。但是，它們有一個自然的識別字——即（workchain_id，account_id），因為任何帳戶鏈裡都包含有關狀態資訊和準確的某一帳戶的更新資訊（無論是簡單帳戶還是智慧合約，區別並不重要）。

#### 2.1.10	分片鏈的動態拆分和合併（參照2.7）。
不那麼複雜的系統可以使用靜態分片——例如，通過使用 account_id 的前八位來選擇 256 個
預定義分片中的一個。
TON區塊鏈的一個重要特徵是它實現了動態分片，這意味著分片數量不固定。相反，如果滿足某些條件（實際上，如果原始分片上交易負荷負載在很長一段時間內足夠高的話），則分片shard (w, s) 可以自動細分為分片shards (w, s.0) 和(w, s.1) 。反過來如果負載在一段時間內都很低，則分片shards (w, s.0) 和(w, s.1) 可以自動合併並退回shard (w, s) 。
最初，只為工作鏈 w 創建了一個分片shard (w, ∅) 。之後，如果有必要，它會細分為更多分片
（參見2.7.6和2.7.8）。
 
#### 2.1.11	基礎工作鏈或初始工作鏈（Workchain Zero）。
雖然使用特定的規則和交易可以定義多達232條工作鏈，但我們最初只定義了一條工作鏈， workchain_id = 0。這個稱為基礎工作鏈或初始工作鏈（Workchain Zero），它是用於處理TON智慧合約和轉移TON coins的工作鏈，也稱為Grams（參照附錄a）。大多數應用程式只需要初始工作鏈。基礎工作鏈的分片鏈將被稱為基礎分片鏈（basic shardchains）。

#### 2.1.12	出塊時間。
我們期望每五秒在每個分片鏈和主鏈上生成一個新區塊。這可以將交易確認時間縮到非常短。所有分片鏈的新區塊幾乎同時生成；而主鏈將在大約一秒後生成一個區塊，因為它包含所有 分片鏈的最新區塊的雜湊值。

#### 2.1.13	通過主鏈使工作鏈和分片鏈緊密耦合。
一旦分片鏈生成的某個區塊的雜湊值被合併到主鏈的某個區塊中，這個分片鏈區塊和它的父塊都會被認為是 “經典的”，這意味著之後所有分片鏈出的區塊都可以引用它們，因為它們是固定且不可更改的。實際上，每個新的分片鏈區塊都包含最新主鏈區塊的雜湊值，並且引用自主鏈區塊的所有分片鏈區塊被視為新區塊，且不可變。

也就是說，這意味著在分片連區塊中提交的交易或消息可以安全用於其他分片鏈的下一系列區塊中，且無需等待。比如基於前一筆交易，你在發送消息或採取其他行動之前，需要系統的20 個確認（即在同一區塊鏈中原始區塊之後生成的 20 個區塊），這在大多數 “鬆散耦合” 系統（參見 2.8.14）裡是常見的，例如 EOS。但是在我們的 “緊密耦合” 系統中，你提交後僅僅5秒就後能在其他分片鏈中發送交易和消息，這種能力是我們相信它的原因，這也是第一個能提供這種前所未有性能的系統（參見 2.8.12 和 2.8.14）。

#### 2.1.14	主鏈（Masterchain）區塊的雜湊作為一個全域狀態（global state）。
根據 2.1.13，整體來看，最後一個主鏈區塊的雜湊值確定了系統的全域狀態。 而無需分別監視其他 shardchains 的狀態。

#### 2.1.15	驗證人（Validators）生成新區塊；參照 2.6。
TON區塊鏈使用 Proof-of-Stake（PoS）在分片鏈和主鏈中生成新區塊。這意味著會存在幾百個驗證人——那些已經進行存幣（大量的TON coins）質押的特殊節點，通過一個特殊的主鏈交易才有資格成為驗證人並生成新區塊。

然後，以確定的偽隨機方式將小量子集驗證人分配給每個分片shard (w; s) ，大約每 1024 個區塊改變一次。這些子集驗證人通過從用戶端收集合適的擬議中交易給新的有效候選區塊，會提出建議並就下一個分片區塊的內容達成共識。對於每個區塊，驗證人都存在偽隨機選擇的順序，以確定每一輪中誰的候選區塊享有最高出塊優先順序。

驗證人和其他節點會檢驗被提名的候選區塊的有效性；如果驗證人簽署了無效性，則會受到自動懲罰，丟失部分或全部的質押代幣，或者在一段時間內不許繼續做驗證人。在此之後，驗證人應該就下一個區塊的選擇達成共識，主要通過 BFT共識協議（拜占庭容錯；參見 2.8.4）的有效變體，類似於pBFT【4】或者Honey Badger BFT【11】。如果達成共識，則創建新區塊
，驗證人會瓜分該塊的交易費用和新造代幣（挖礦）獎勵。
 
每個驗證人可以選擇參與幾個驗證人子集；這種情況下，所有驗證和共識演算法都會同時運行。在所有新的分片鏈生成區塊或出塊超時後，一個主鏈區塊將會生成，它包括所有分片鏈最新區塊的雜湊值。這是由驗證人通過BFT共識完成的。3

有關TON PoS的方法及其經濟模型的更多詳細資訊，請參見第 2.6 節。

#### 2.1.16	主鏈（masterchain）分叉。
我們採用緊密耦合導致的複雜性是，轉換到主鏈的一個不同分叉幾乎必然要求在一些分片鏈上轉換到另一分叉。另一方面，只要主鏈中沒有分叉，分片鏈就不可能分叉，因為分片鏈區塊的雜湊值都是合併到主鏈區塊中，分片鏈的備用分叉中沒有區塊能夠成為“經典”。

一般規則是，如果主鏈區塊B'是區塊B的上一個區塊，則區塊B'包含分片鏈(w; s)的區塊B’w;s的雜湊值Hash (B’w;s)，且區塊B包括雜湊值Hash (Bw;s)，那麼區塊B’w;s也是區塊Bw;s的上一個區塊。否則，主鏈區塊B無效。

我們預計主鏈幾乎不會分叉，因為TON區塊鏈採用的BFT共識下，只有在大多數驗證人行為不正確的情況下才可能發生這種情況（參見2.6.1和2.6.15），這將意味著違法者會遭受重大損 失。因此可以說，分片鏈中不會有真正的分叉。相反，如果檢測到無效的分片鏈，它會通過2-blockchain的“垂直區塊鏈”機制（參見2.1.17）進行糾正就可以實現這一目標，而無需分叉
“水準區塊鏈”（horizontal blockchain，即分片鏈）。同樣的機制也可用於修復主鏈區塊中的非致命錯誤。

#### 2.1.17	更正無效的分片鏈區塊。
通常情況下，只有有效的分片鏈區塊才能出塊，因為分配到分片鏈的驗證人必須有三分之二達到拜占庭共識，新區塊才能出塊。然而，系統必須先允許檢測之前已經出的無效區塊並校正。

當然，一旦找到無效的分片鏈區塊——由驗證人（不一定是負責這個分片鏈的）或 “漁夫”（ fisherman）；系統內的一種節點，可以存入一定代幣然後提出有關區塊有效性的問題；參見2.6.4）——當無效性的聲明及其證據被提交到主鏈時，簽署區塊無效性的驗證人將收到懲罰
——失去部分質押和/或暫時從驗證人陣營中退出（後一種措施面對攻擊者竊取其他良性驗證
人的簽名私密金鑰這種情況時很重要）。

然而這還不夠，因為系統（TON Blockchain）的整體狀態由於先前釋放的分片鏈區塊無效而被證明是無效的。必須使用較新的有效區塊替換此無效塊。

大多數系統都會 “回退” 至分片鏈無效區塊的前一個區塊來實現此目的，再之前的其他區塊不受其他每個分片鏈中的無效區塊傳播的消息影響。並從這些區塊開始分叉。這種方法的缺點是許多其他正確的和已提交的交易突然回退，並且不清楚這些回退的交易是否稍後將被包括在 內。

TON區塊鏈通過使每個分片鏈和主鏈（即“水準區塊鏈”[horizontal blockchains]）的每個 “區
塊” 自身成為一個社區塊鏈（即“垂直區塊鏈”[vertical blockchain]）來解決這個問題，包含不同

3 實際上，三分之二的驗證人就足以達成共識，但盡可能多的簽名是更好的。
 
版本的 “區塊” 或它們的 “差異””。通常，垂直區塊鏈只包含一個區塊，而分片鏈看起來像一個經典的區塊鏈。然而，一旦確認塊的無效性並將其提交到主鏈區塊中，則允許無效區塊的 “垂直區塊鏈” 在垂直方向上由新區塊增長，從而替換或編輯無效區塊。新區塊由相關分片鏈的當前驗證人子集來生成。

新的 “垂直” 區塊規則的有效性非常嚴格。特別是如果無效區塊中包含著一個虛擬的 “帳戶鏈區
塊”（參見 2.1.2）本身有效，則必須保持新的垂直塊不變。

一旦在無效區塊之上提交了一個新的“垂直”區塊，其雜湊值就會發佈在新的主鏈區塊中（或者說在一個新的“垂直”區塊中，該區塊位於原始主鏈區塊上方，原始主鏈區塊是最初用來發佈無效的分片鏈區塊雜湊值的地方），這些改變進一步擴散到任何的分片鏈區塊中，這些分片鏈區塊引用該無效區塊的先前版本（例如，那些已從不正確的區塊接收消息的區塊）。這一問題的解決方式是通過在垂直區塊鏈中，為以前引用 “不正確” 區塊的所有區塊提交新的 “垂直” 區塊
；新的垂直區塊將引用最新（已更正）的版本。同樣，嚴格的規則禁止更改未受影響的帳戶鏈
（例如依舊像先前版本那樣照常接收資訊）。通過這種方式，修復不正確的區塊會產生 “連帶效應”，最終傳播到所有受影響的分片鏈的最新區塊；這些變化反映在新的 “垂直”主鏈區塊也是如此。

一旦 “歷史重寫” 的波及最新的區塊，新的分片鏈區塊僅在一個版本中生成，僅作為最新區塊版本的接續。這意味著它們將從一開始就包含對正確（最近）垂直區塊的引用。

主鏈狀態隱含地定義了將每個 “垂直” 區塊鏈的第一個區塊的雜湊值轉換為其最新版本雜湊值的映射。這使客戶能夠通過第一個（通常是唯一的）區塊雜湊值來驗證和定位任何 “垂直區塊鏈” 。

#### 2.1.18	TON coins和多貨幣工作鏈（multi-currency workchains）。
TON區塊鏈最多支持232種不同的“加密貨幣（cryptocurrencies）”、 “幣（coins）”, 或者 “代幣
（tokens）”，由 32 個位元組的currency_id作為區分。可以通過主鏈中的特殊交易添加新的加密貨幣。每個工作鏈都有一個基礎的加密貨幣，並且可以有幾個額外的加密貨幣。

有一種特殊的加密貨幣，currency_id = 0，叫作TON coin，也被稱為Gram（參見 附錄A） 。它是初始工作鏈（Workchain Zero）的基礎加密貨幣。它還用作交易費和驗證人的抵押資
產。

原則上，其他工作鏈可能會收取其他代幣作為交易費用。這種情況下，應該提供一些智慧合約
，將這些交易費用自動轉換為Grams。

#### 2.1.19	消息的傳遞與價值轉移。
屬於相同或不同工作鏈的分片鏈可以相互發送消息。雖然允許的消息格式取決於接收工作鏈和接收帳戶（智慧合約），但有一些共同的欄位讓工作鏈間消息傳遞成為可能。特別是每個事件可以附加一些價值，價值的形式是一定數量的Grams（TON coin）和/或其他已註冊的加密貨幣，倘若這些已註冊的加密貨幣是被接收工作鏈聲明為可接受的加密貨幣。
這種消息傳遞的最簡單形式是從一個（通常不是智慧合約）帳戶到另一個帳戶的價值轉移。

#### 2.1.20	TON虛擬機器。
 
TON虛擬機器（也稱為TON VM或TVM）是用於在主鏈和基礎工作鏈中執行智慧合約代碼的虛
擬機。其他工作鏈可以同時使用其他虛擬機器或者用其他虛擬機器代替TVM。 在這裡我們列出了它的一些功能。它們將在 2.3.12、2.3.14 中進一步討論。
•	TVM將所有資料表示為（TVM）單元（cell）的集合（參見 2.3.14）。每個單元最多包含128位元組的資料，最多包含 4 次對其他單元的引用。由於 “一切都是一組單元” 的理念（參見 2.5.14），這使得TVM能夠處理與TON區塊鏈相關的所有資料，如有必要，包括區塊和區塊鏈全域狀態。
•	TVM可以處理任意代數資料類型的值（參見 2.3.12），以TVM細胞裡的Merkle樹或DAG為代表。但它只對單元有效，對代數資料類型未知。
•	TVM內置了對雜湊圖的支持（參見 2.3.7）。
•	TVM是一台堆疊機器。它的堆疊保持著64 位元整數或對單元的引用。
•	支持64位、128位和256位算術。所有n位算數運算有三種形式：不帶正負號的整數、有符號整數和模數2n整數（後一種情況下不進行自動溢出檢測）。
•	TVM具有從n位元到m位元的無符號和有符號整數轉換，對於所有0≤m，n≤256，帶有溢出檢查。
•	預設情況下，所有算數運算都執行溢出檢查，大大簡化了智慧合約的開發。
•	TVM具有 “先乘法後位移運算” 和“先位移後除法運算” 的算數運算方式，其中間值以
較大的整數類型計算；這簡化了實現定點算術的過程。
•	TVM支援二進位字元串和位元組字串。
•	支援對一些預定義曲線（包括Curve25519）的256位元橢圓曲線加密演算法（ECC）。
•	還存在對某些橢圓曲線上的Weil配對的支持，這有利於快速實現zk-SNARK。
•	支援流行的雜湊函數，包括SHA256。
•	TVM可以使用Merkle證明（參見 5.1.9）。
•	TVM為 “大型” 或 “全域” 的智慧合約提供支援。這種智慧合約必須意識到分片技術
（參見 2.3.18 和 2.3.16）。而本地智慧合約不用知道是否分片。
•	TVM支持閉包。
•	可在TVM內輕鬆實現STG（spineless tagless G-machine）【13】。
除了 “TVM元件” 之外，還可以為TVM設計幾種高階語言。所有這些語言都將具有靜態類型， 並將支援代數資料類型。我們設想了以下可能性：
•	類似 Java 的命令式語言，每個智慧合約類似於一個單獨的類別。
•	一種惰性的函數式語言（設想一下Haskell）。
•	熱切的功能語言（設想一下ML）。

#### 2.1.21	可配置的參數。
TON區塊鏈的一個重要特徵是它的許多參數都是可配置的。這意味著它們是主鏈狀態的一部分，並且可以通過主鏈中的某些特殊提案/投票/結果交易記錄進行更改，而無需任何硬分叉。改變這些參數需要收集三分之二的驗證人投票，以及所有其他參與投票過程中支持該提案的參與者的一半以上的投票。

### 2.2	區塊鏈概述
#### 2.2.1	一般區塊鏈定義。
一般來說，任何（真）區塊鏈都是一個區塊序列，每個區塊B包含一個引用blk-prev(B)，該引用是對對上一個區塊（通常是通過將上一個區塊的雜湊值包含到當前區塊的區塊頭）和交易清單的引用。每筆交易都描述了全域區塊鏈狀態的轉型；在一個區塊中列出的交易有序地被引用
 
來計算新狀態，這個新狀態是從舊狀態開始的，新狀態也是前一個區塊評測之後出來的結果狀
態。

#### 2.2.2	TON區塊鏈的相關性。
回想一下，TON區塊鏈不是真正的區塊鏈，而是二維區塊鏈的集合（即區塊鏈的區塊鏈；參見 2.1.1），因此上述內容並不直接適用於它。但我們從真正區塊鏈的一般性開始，將它們用作我們構建更複雜結構的區塊。

#### 2.2.3	區塊鏈實例和區塊鏈類型。
人們經常使用區塊鏈這個詞來表示一般的區塊鏈類型及其特定的區塊鏈實例，它們被定義為滿足某些條件的區塊序列。例如，2.2.1指是區塊鏈實例。

以這種方式，區塊鏈類型通常是類型Block∗的“子類型”，類型Block∗是區塊的列表（即，有限序列），由滿足某些相容性和有效性條件的那些區塊序列組成：

Blockchain ⊂ Block∗	(1)

定義區塊鏈的更好方法是說區塊鏈是一個依賴成對類型（dependent couple type），由一對值(B,v)組成，第一個組成部分B :Block∗是類型Block∗（例如區塊的列表），第二個組成部分v:isValidBc(B )是B 的有效性的證明或見證。運算式是這樣，

Blockchain ≡ Σ(B:Block∗) isValidBc(B)	(2)
我們在這裡使用的標記法是依賴型求和類型，參考【16】。

#### 2.2.3 依賴類型理論（Dependent type theory），互動式的定理證明器（Coq
）和類型語言（TL）。
請注意，我們在這裡使用（Martin-Löf）依賴類型理論，類似於Coq4證明助手中使用的理論。依賴類型理論的簡化版本也用於類型語言（TL）5，將在TON區塊鏈的正式規範中使用它來描述所有資料結構的序列化結構以及塊、交易等的排列方式。

實際上，依賴類型理論（Dependent type theory）給出了一種證明的可用形式，這種形式證
明（或者是它們的序列），會在比如需要為某些區塊提供無效證明時變得很方便。

#### 2.2.5	類型語言（TL / Type Language）。
由於類型語言（TL）將用於TON區塊、交易和網路資料包的正式規範中，因此有必要進行簡短的討論。

類型語言是一種適用於描述依賴型代數類型的語言，允許使用數位（自然）和類型參數。通過幾個構造函數描述每種類型。每個構造函數都有一個（人類可讀的）識別字和一個名稱，它是一個位字串（預設情況下為32位元整數）。除此之外，構造函數的定義包含欄位清單及其類型。

----

4 https://coq.inria.fr
5 https://core.telegram.org/mtproto/TL

---

構造函數和類型定義的集合稱為TL-scheme。它通常保存在一個或多個帶有尾碼 .tl 的文件中。

TL-schemes的一個重要特徵是它們確定了一種明確的對已定義的代數類型值（或物件）進行序列化和反序列化的方法。也就是說，當需要將值序列化為位元組流時，首先用於此函數值的構造函數的名稱會被序列化。遞迴計算每個欄位的序列化如下。

對TL的先前版本的描述，適用於將任意物件序列化為32位元整數序列，這可以參考： https://core.Teleggram.org/MTProto/TL。一種TL的新版本TL-B正在研發，用於描述物件的序列化，這個新版本被TON項目採用。這個新版本可以將物件序列化為位元組流甚至位元流（不僅僅是32位元整數），並且支援將序列化應用到TVM單元樹中（參見 2.3.14）。TL-B的描述將是TON區塊鏈的正式規範的一部分。

#### 2.2.6	區塊和交易作為狀態轉換運算子。
通常，任何類型的區塊鏈（類型）Blockchain都具有關聯的全域狀態（類型）State 和交易
（類型）Transaction。 區塊鏈的語義在很大程度上取決於交易應用程式的功能：

ev_trans’ : Transaction × State → State?	(3)

這裡X?表示MAYBE X，是應用MAYBE monad到類型X的結果。這與我們使用X*表示列表X類似。實際上，類型X? 的值要麼是類型X的值，要麼表示沒有實際值（設想一下null pointer）的特殊值⊥。在我們的例子中，我們使用State?而不是State作為結果類型，因為如果從某些原始狀態請求（試想試圖從一個帳戶取出比帳戶中實際更多的錢），交易可能無效。
我們可能更喜歡ev_trans'的改進版本：

ev_trans : Transaction → State → State?	(4)

因為一個區塊本質上是一個交易清單，區塊評價函數

ev_block : Block → State → State?	(5)

可以從ev_trans派生。它需要一個區塊B : Block和前一個區塊鏈狀態s : State（可能包括前一個區塊的雜湊值）並計算下一個區塊鏈狀態s′ = ev_block(B)(s) : State，它要麼是一個真實狀態或者是特殊值⊥，表示無法計算下一個狀態（即如果從給定的起始狀態進行評估，則該塊無效——例如，該區塊包括一筆試圖從空帳戶收款的交易）。

#### 2.2.7	區塊序號（Block sequence numbers）。
區塊鏈中的每個區塊B可以通過序號BLK-SEQNO(B) 來引用，從第一個區塊的0開始，並且每當傳遞到下一個塊時遞增1。正式的公式：
BLK-SEQNO(B) = BLK-SEQNO( BLK - PREV(B) ) + 1	(6)

請注意，在分叉出現時，序號不是用來唯一識別一個區塊的。

#### 2.2.8	區塊雜湊值（Block hashes）。
 
引用區塊B的另一種方式是通過其雜湊值BLK-SEQNO(B)，實際上是區塊B區塊頭的雜湊值
（然而，區塊的區塊頭通常包含區塊B的所有內容的雜湊值）。假設所使用的雜湊函數沒有衝突（或者至少它們非常不可能產生衝突），則通過其雜湊值可以唯一地標識區塊。

#### 2.2.9	雜湊假設（Hash assumption）。
在區塊鏈演算法的形式分析期間，我們假設使用的k-bit的雜湊函數 HASH : Bytes* → 2k沒有衝突：

Hash(s) = Hash(s’) ⇒ s = s’	對任意s，s’ ∈ Bytes*	(7)

這裡 Bytes = {0...255} = 28次方的位元組類型，或者是所有位元組值的集合，Bytes*是任意（有限）位元組清單的類型或集合； 而2 = {0,1}是位類型，2k次方是所有k-bit的序列（即k-bit的編號）的集合（或實際類型）。

當然，（7）在數學上是不可能的，因為從無限集到有限集的映射不能是單射的。一個更嚴謹的假設是：

∀ s,s’ : s ≠ s’, P(Hash(s) = Hash(s’)) = 2-k	(8)

然而，這對於證明來說並不方便。對於某些小值的 ε（例如，ε=10-18），如果（8）在2-kN < ε
的證明中最多使用 N 次，倘若我們接受失敗概率 ε（即最終結論將會為真的概率至少是1-ε）
，我們可以推論（7）似乎為真。

最後評論：為了使（8）的概率陳述真正嚴謹，必須在所有位元組序列的集合Bytes* 中引入概率分佈。這樣做的一種方法是假設所有相同長度l的位元組序列是等概率的，並且設置觀察長度l的序列的概率等於pl - pl+1（對於某些p→1-）。然後當p從更小值趨近于1時，（8）應該被理解為條件概率P(Hash(s) = Hash(s’)|s ≠ s’)的一種極限狀態。

#### 2.2.10	雜湊作用于TON區塊鏈。
我們暫時在TON區塊鏈中使用256位元的SHA256雜湊函數。如果結果比預期的要差，那麼將來可以用另一個雜湊函數來替換它。雜湊函數的選擇是協定的可配置參數，因此可以在不進行硬分叉的情況下更改，如 2.1.21 中所述。

### 2.3	區塊鏈狀態、帳戶和雜湊表
我們在上文中已經注意到，全域狀態由每一個區塊鏈來決定，每個區塊和每個交易都定義了全域狀態的變化。這裡我們描述TON區塊鏈使用的全域狀態。

#### 2.3.1	帳戶 ID。
TON 區塊鏈使用的基礎帳戶ID——或者至少是其主鏈和初始工作鏈使用的基礎帳戶ID，是256 位元整數，對於一個特定的橢圓曲線，基礎帳戶ID假定為256位元橢圓曲線加密（ECC）的公開金鑰。用這種方式，

account_id : Account = uint256 = 2256	(9)
 
此處Account是帳戶類型，而 account_id是帳戶類型的特定變數。
其他工作鏈可以使用其他帳戶ID格式，256位或其他。 例如，可以使用比特幣類型的帳戶ID， 等於ECC公開金鑰的SHA256。
但是，在創建工作鏈（在主鏈上）期間，帳戶ID的位長度l必須是固定的  ，並且它必須至少為
64位，因為account_id的前64位是用於分片和按路由發送消息的。

#### 2.3.2	主要組成部分：Hashmaps。
TON區塊鏈狀態的主要組成部分是hashmap。在某些情況下，我們考慮（部分定義）“map”h
：2n ---> 2m。或者通俗地說，我們可能對雜湊圖 h 更感興趣：h : 2n --->X 表示複合型X。但是源（或索引）類型幾乎總是2n 。
有時，我們的“預設值”為空值：X, 雜湊圖為 h : → X， “初始化”狀態是“預設值” i |→ 空值。

#### 2.3.3	示例：TON帳戶餘額。
TON帳戶餘額給出了一個重要的例子：

balance : Account → uint128	(10)

就是這個 hashmap將Account = 2256 映射至類型 uint	= 2128 的Gram (TON coin)餘額。該
hashmap的預設值為零，這意味著最初（在處理第一個塊之前）所有帳戶的餘額為零。

#### 2.3.4	示例：智慧合約的永久存儲。
另一個例子是智慧合約永久存儲，它可以（非常近似地）表示為一個hashmap：

storage : 2256 ---> 2256	(11)

該hashmap的預設值也為零，意味著假設未初始化的永久存儲單元個數為零。

#### 2.3.5	示例：永久存儲所有的智慧合約。
因為我們有多個智慧合約，由account_id來區分，每個都要獨立的永久存儲，所以必須有一個
hashmap

Storage : Account --->（2256 ---> 2256）	(12)

將智慧合約的account_id映射到其永久存儲裡。

#### 2.3.6	hashmap的類型。
Hashmap不僅僅是一個抽象的（部分定義的）函數2n ---> X； 它有一個特定的標記法。 因此
，我們假設我們有一個特殊的hashmap類型
Hashmap(n, X) : Type	(13)

對應於編碼（部分）圖2n ---> X的資料結構。我們也可以寫為

Hashmap(n : nat)(X : Type) : Type	(14)
 
或者

Hashmap : nat → Type → Type	(15)

我們也可以將h : Hashmap(n, X)轉換成一個map：hget(h) : 2n → X?。之後，我們通常寫h[i]來替代 hget(h)(i)：

h[i] :≡ hget (h)(i) : X?	對於任意 i : 2n, h : Hashmap (n, X)	(16)

#### 2.3.7	把hashmap的類型當作Patricia樹。
從邏輯上講，可以將Hashmap (n，X)定義為深度為n的（不完整）的二叉樹（binary tree），
邊緣標籤為0和1，葉片中有類型X的值。描述相同結構的另一種方式是（按位元）首碼樹（trie
），用於長度等於n的二進位字元串。

在實踐中，我們更喜歡使用此首碼樹的壓縮標記法，通過壓縮每個頂點的父節點只帶有一個子節點。結果表示為Patricia樹或者二進位基數樹。每個中間頂點現在有兩個子節點，由兩個非空二進位字元串標記，左邊子節點為0，右邊的子節點為1。

換句話說，Patricia樹中有兩種類型的（非根）節點：
•	葉子LEAF(x), 包含類型X的值x；
•	節點NODE (l,sl,r,sr)，其中l是對左邊子節點或子樹（的引用），sl是用於標記連接此頂點到左邊子節點的邊緣的位元字串（總是從0開始），r是右邊的子樹，而sr是位元字串用於右邊子節點的邊緣（總是以1開頭）。

第三種類型的節點，僅在Patricia樹的根部使用一次，也是必要的：
•	根ROOT(n,s0,t)，其中n是Hashmap (n，X)的索引位元字串的公共長度，s0是所有索引位元字串的公共首碼，t是對Leaf或Node的引用。
如果我們想讓Patricia樹為空值，將使用第四種類型的（根）節點：
•	空根EmptyRoot(n) ，其中n是所有索引位元串的公共長度。我們定義 Patricia 樹的高度

HEIGHT (LEAF (x)) = 0	(17)
HEIGHT (NODE (l,sl,r,sr)) = HEIGHT (l) + LEN (sl) = HEIGHT (r) + LEN (sr)	(18) HEIGHT (ROOT (n,s0,t)) = LEN (s0) + HEIGHT (t) = n	(19)

最後兩個公式中每個公式中的最後兩個運算式必須相等。我們使用高度為n的Patricia樹來表示
Hashmap (n , X)類型的值。
如果樹中有N葉子（即我們的hashmap包含N個值），則恰好有N-1個中間頂點。插入新值總是涉及通過在中間插入新頂點並添加新分支作為此新頂點的另一個分支來分割現有邊界。從雜湊表中刪除值則相反：刪除了一個葉子及其上級，則上級的上級與其他葉子直接連接。

#### 2.3.8	Merkle-Patricia樹（MPT樹）。
使用區塊鏈時，我們希望能夠比較Patricia樹（即雜湊表）及其子樹，方法是將它們減少為單個雜湊值。Merkle樹給出了實現這一目標的經典方法。本質上，假使是我們知道如何計算物件x :  X的雜湊HASH(x)（例如，通過將雜湊函數 Hash應用於物件x的二進位序列化），借助為
 
二進位字元串定義的雜湊函數Hash，這是我們想要描述一種類型雜湊圖 Hashmap(n，X)的對
象h的一種方法。
可以遞迴地定義HASH (h)，如下所示：

HASH (LEAF (x)) = HASH (x)	(20) HASH (NODE (l,sl,r,sr)) = HASH (HASH (l). HASH (r). CODE (sl). CODE (sr))	(21)
HASH (ROOT (n,s0,t)) = HASH (CODE (n). CODE (s0). HASH (t))	(22)

這裡s.t表示（位元）字串s和t的關係，並且代碼CODE(s)是所有位元字串s的前置碼。例如， 可以用10編碼0，用11編碼1，在字串結尾用0編碼。6
稍後我們將看到（參見2.3.12和2.3.14）這是遞迴定義的雜湊函數的一個（稍微調整過的）版本，用於任意（從屬）代數類型的值。

#### 2.3.9	重新計算Merkle樹的雜湊值。
這種遞迴定義Hash (h)的方式稱為Merkle樹雜湊，其優點是，如果一個人明確地將Hash (h'） 與每個節點h'一起存儲（產生一個稱為Merkle樹的結構， 或者在我們的例子中，叫作
Merkle-Patricia樹），在hashmap中添加、刪除或更改一個元素時，只需要重新計算最多n個雜湊值。

用這種方法，如果通過合適的Merkle樹雜湊表示全域區塊鏈狀態，則在每次交易後很容易重新
計算此狀態雜湊值。

#### 2.3.10	Merkle證明。
所選雜湊函數Hash在 “內射” （injectivity）的假設（7）下，我們可以構造一個證明，對於Hash (h)的給定值z，h：Hashmap (n，X)，有一個hget (h)(i) = x， 對於某些 i: 2n 和 x:X。這樣的證明將包括 Merkle-Patricia樹中的路徑，這種路徑從對應于i到葉子到根，由出現在路徑上的所有兄弟節點的雜湊值來增強。

以這種方式，一些僅知道雜湊圖h的Hash (h)值的輕節點7（例如，智慧合約永久存儲或全域區塊鏈狀態）可以從完整節點8請求，請求的內容不僅是值 x = h [i] = hget (h) (i)，而且是伴隨著從已知值 Hash (h)開始的Merkle證明。然後，在假設（7）下，輕節點可以檢查自身，x確實是h [i]的正確值。

而在一些情況下，用戶端可能想要獲得值 y = Hash（x）= Hash (h [i])——例如，如果 x 本身非常大（例如，hashmap本身）。然後可以提供(i , y)的Merkle證明。如果x也是雜湊函數，則從 y = Hash (x)開始的第二個Merkle證明可以從完整節點獲取，以提供值 x[j] = h [i] [j] 或僅其雜湊值。

---

6 可以表明這種編碼對於帶有隨機或連續索引的Patricia樹的幾乎一半邊緣標籤是最佳的。剩餘的邊緣標籤可能很長（即幾乎256位長度）。因此，邊緣標籤的近似最佳編碼是使用上面的代碼，該代碼用首碼為0表示“短”位元串字串，並編碼1，剩下9位元包含位元字串s的長度l = |s|，然後用s的l表示“長”位元字串
（l ≥ 10）
7 輕節點不追蹤分片鏈的完整狀態;相反，它保留最少的資訊，例如最近幾個塊的雜湊值，並且當需要檢查完整狀態的某些部分時，依賴於從完整節點獲得的資訊。
8 完整節點用於追蹤被提及的分片鏈的完整最新狀態。

---

#### 2.3.11	對於諸如TON的多鏈系統，Merkle證明的重要性。
請注意，節點通常不能是存在於TON環境中所有分片鏈的完整節點。它通常是一種針對一些分片鏈的全節點——例如，那些包含自己帳戶的分片鏈，對智慧合約感興趣的分片鏈，或者這個節點被指定為驗證人的那些分片鏈。對於其他的分片鏈，它必須是一個輕節點——否則存 儲、計算和網路頻寬要求會非常高。這意味著這樣的節點不能直接檢查關於其他分片鏈狀態的斷言（assertion）； 對於這些分片鏈，它必須依賴于從全節點獲得的Merkle 證明，這與自身檢查一樣安全，除非(7)失敗（即發現雜湊衝突）。

#### 2.3.12	TON VM的特點。
用於在主鏈和初始工作鏈中運行智慧合約的TON VM或TVM（Telegram虛擬機器）與受EVM
（乙太坊虛擬機器）啟發的傳統設計有很大不同：它不僅用256位元整數操作 ，而且實際上（幾乎是）帶有任意 “記錄”、“結構” 或 “和產品類型”，使其更適合執行用高級（特別是函數程式設計）語言編寫的代碼。 從本質上講，TVM使用標記資料類型，與實現Prolog或Erlang時使用的資料類型還不同。

人們首先可能想到的是，TVM智慧合約的狀態不僅僅是一個hashmap 2256 → 2256，或者Hashmap (256 , 2256 )，但是（作為第一步）Hashmap (256 , X)，其中X是具有多個構造函數的類型，使其能夠存儲除256位元整數之外的其他結構的資料，包括其他hashmap，特別是Hashmap (256 , X)。這意味著TVM（永久或臨時）存儲的單元——或 TVM 智慧合約代碼中的變數或陣列元素——不僅可以包含整數，而且可以包含全新的雜湊表。當然，這意味著一個單元不僅包含256位元，而且還包含一個8位標籤，描述了如何解析這個256位。

實際上，值不需要精確為 256 位。TVM 使用的值的格式包括一系列原始位元組和對其他結構的引用，以任意順序混合，其中一些描述符位元組插入適當的位置，以便能夠區分指標與原始資料
（例如，字串或整數）；參照 2.3.14。

該原始值格式可用於實現任意和積（SPN）代數類型。在這種情況下，該值首先包含一個原始位元組描述正在使用的 “構造函數”（從高階語言的角度來看），然後是其他 “欄位” 或 “構造函數參數”，其中包括原始位元組和對其他結構的引用，這些結構取決於所選擇的構造函數（參見2.2.5）。然而，TVM對構造函數與其參數之間的對應關係一無所知；位元組和引用的混合由某些描述符位元組明確描述。9

Merkle樹雜湊擴展到任意這樣的結構：為了計算這種結構的雜湊，所有引用都提及物件的雜湊
值遞迴替換，然後計算得到的結果位元組字串（包括描述符位元組）的雜湊。

通過這種方式，2.3.8中描述的針對Hashmap的Merkle樹雜湊，只是對任意（依賴型）代數資料類型進行雜湊的特殊情況，應用於具有兩個構造函數的Hashmap (n，X)類型。10

#### 2.3.13	永久存儲TON智慧合約。

---

9 存在於任何TVM細胞中的這兩個描述符位元組僅描述引用和原始位元組的總數；參考文獻在所有原始位元組之前或者之後一起保存。
10 實際上，Leaf和Node是輔助類型HashmapAux (n，X)的構造函數。類型Hashmap (n，X)帶有構造函數Root和EmptyRoot，其中Root包含類型HashmapAux (n，X)的一個值。

---

對於一個TON智慧合約的永久存儲本質上由它的 “全域變數”組成，這些“ 全域變數”保存在智慧合約的調用之間。因此，它只是一個 “產品”、“元組” 或 “記錄” 類型，由正確類型的欄位組成
，每個欄位對應一個全域變數。如果全域變數太多，由於對TON單元體積的全域限制，它們則不能歸屬於一個TON單元。在這種情況下，它們被分成若干記錄並組織成樹，本質上成為了 “產品的產品” 或 “產品的產品的產品” 類型，而不僅僅是產品類型。

#### 2.3.14	TVM單元。
最終，TON VM將所有資料保存在（TVM）單元的集合（Collection）中。每個單元首先包含兩個描述符位元組，指示該單元中存在多少位元組的原始資料（最多 128 個），以及存在多少個對其他單元的引用（最多四個）。然後是這些原始資料位元組和引用。每個單元只被引用一次， 因此我們可能已經在每個單元中包含對其 “父” （引用該單元的唯一單元）的引用。但是，該引用不必明確說明。

以這種方式，TON智慧合約的永久資料存儲單元被組織成樹11，其中智慧合約描述中保存了對該樹的根的引用。如有必要，整個永久記憶體的Merkle樹雜湊值被遞迴計算了，從樹葉開始， 然後簡單地用被引用單元的遞迴計算的雜湊值代替一個單元中的所有引用，並隨後計算由此獲得的位元組字串的雜湊值。

#### 2.3.15	任意代數類型值的廣義Merkle證明。
因為TON VM通過由（TVM）單元組成的樹來表示任意代數類型的值，並且每個單元具有明確定義的（遞迴計算的）Merkle雜湊，實際上取決於根據該儲存格生成的整個子樹，所以我們可以為任意代數類型的（部分）值提供 “廣義Merkle 證明”，旨在證明具有已知Merkle雜湊的樹的某個子樹採用特定值或具有特定雜湊的值。這概括了 2.3.10的方法，其中只考慮了x[i] = y的Merkle證明。

#### 2.3.16	支援TON VM資料結構中的分片。
我們剛剛概述了TON VM如何在不過度複雜的情況下支援高級智慧合約語言中的任意（依賴型）代數資料類型。但是，大型（或全域）智慧合約的分片需要在TON VM層面提供特殊支援。為此，系統中添加了特殊版本的hashmap類型，相當於一個 “map” Account ---> X。這個“map” 似乎等同於Hashmap (m，X)，其中Account = 2m。但是，當分片一分為二或兩個分片合併時，這些雜湊圖會自動拆分成兩個或合併回來，目的是為了保持只有那些屬於相應分片的鑰。

#### 2.3.17	為永久存儲支付。
TON區塊鏈的一個值得注意的特徵是從智慧合約中提取的支付的用於存儲其永久資料的支付
（即，用於擴大區塊鏈的總狀態）。它的工作原理如下：

每個區塊有兩種費率，以區塊鏈的主要貨幣（通常是 Gram）指定：一種是將一個單元保留在永久存儲中的價格，另一種是在永久存儲的某個單元中保留一個原始位元組的價格。每個帳戶使用的細胞和位元組總數的統計資訊存儲為其狀態的一部分，因此通過將這些數位乘以區塊頭中的

---

11 從邏輯上講， 2.5.5中描述的“bag of cells””表述確認所有重複單元，在序列化時將此樹轉換為有向無
環圖（dag）。

---

兩種費率，我們可以計算要從帳戶餘額中扣除的付款以便在前一個區塊和當前區塊之間保留資料。

但是，為使用永久存儲而付款，並不強求每個區塊中的每個帳戶和智能合約；相反，最後要求該支付的區塊序號存儲在帳戶資料中，當該帳戶進行任何動作時（例如，通過智慧合約接收和處理價值轉移或消息）， 在執行任何進一步動作之前，會從帳戶餘額中扣除從上一次此類付款以來的所有區塊的存儲使用費用。如果此後帳戶的餘額將變為負數，則該帳戶將被銷毀。工作鏈可以聲明每個帳戶的一些原始資料位元組是 “免費” 的（即，不參與永久性存儲支付）， 以便製作 “簡單” 帳戶，這些帳戶僅用一種或兩種加密貨幣保留餘額，而不用不斷付款。

請注意，如果沒有人向帳戶發送任何消息，則不會收集其永久存儲費用，並且帳戶可以一直存在。但是，任何人都可以發送一條空消息來銷毀這樣的帳戶。想要銷毀帳戶餘額的部分作為小激勵，會提供給這樣的消息的發送者。 我們預計驗證人將樂意銷毀此類資不抵債的帳戶，只是為了減少全域區塊鏈的規模，避免無償地保留大量資料。

為保持永久性資料而收集的付款分佈在分片鏈或主鏈的驗證人之間（後一種情況下與他們的質
押成比例）。

#### 2.3.18	本地和全域智能合約；智慧合約實例。
智慧合約通常只存在於一個分片中，根據智慧合約的account_id選擇，類似于 “普通” 帳戶。對於大多數應用來說，這通常就足夠了。然而，一些 “高負荷” 的智慧合約可能希望在某些工作鏈的每個分片鏈中都有一個 “實例”。為了實現這一點，他們必須將他們的創建的交易傳播到所有分片鏈中，例如，通過將此交易提交到工作鏈的 “root”分片鏈(w，∅)12並支付大額傭金。13 此操作在每個分片中有效地創建了智慧合約的實例，並具有單獨的餘額。最初，在創建交易中傳輸的餘額簡單地通過在shard (w，s)中給出的實例2−|s|作為總餘額的一部分來分佈。當分片分成兩個子分片時，所有全域智慧合約實例的餘額分成兩半；當兩個分片合併時，餘額會加在一起。

在某些情況下，拆分/合併全域智慧合約的實例可能涉及（延遲）執行這些智慧合約的特殊方法。預設情況下，拆分和合併餘額如上所述，並且一些特殊的 “帳戶索引” hashmap也會自動拆分和合併（參見 2.3.16）。

#### 2.3.19	限制智慧合約的分割。
全域智慧合約可能會在創建時限制其拆分深度d，以便使永久存儲費用更具可預測性。這意味著，如果shardchain (w，s)（其中| s | ≥ d）分為兩部分，兩個新的分片鏈中只有一個接替了智慧合約的一個實例。這種分片鏈的選擇是確定性的：每個全域智慧合約都有一些“account_id”，它本質上是創建的交易的雜湊值，並且其實例具有相同的account_id，其中第一個≤d的位替換為落入正確分片所需的適當值。此account_id選擇在拆分後由哪個分片接替智慧合約實例。

#### 2.3.20	帳戶 / 智慧合約狀態。
我們可以總結以上所有內容，得出結論：帳戶或智慧合約狀態包含以下內容：
•	區塊鏈主要貨幣的餘額

---

12 一種更昂貴的替代方案，目的是在主鏈中發佈這種“全域”智慧合約。
13 這是所有分片的一種“廣播”功能，因此它必然是非常昂貴的。

---

•	區塊鏈的其他貨幣餘額
•	智能合約代碼（或其雜湊）
•	智慧合約永久性資料（或其Merkle雜湊）
•	永久存儲單元數和使用的原始位元組數的資料統計
•	最後一次收集智慧合約永久存儲付款（實際上是主鏈區塊編號）
•	從此帳戶傳輸貨幣和發送消息所需的公開金鑰（可選；預設情況下等於account_id本 身）。在某些情況下，可以在此處找到更複雜的用於檢查代碼的簽名，類似於比特幣交易輸出所做的操作； 然後account_id 將等同於此代碼的雜湊值。
我們還需要在帳戶狀態或其他一些帳戶索引的雜湊圖中保留以下資料：
•	帳戶的輸出訊息佇列（參見 2.4.17）
•	最近發送的消息（雜湊）的集合（參見 2.4.23）
並非所有這些都是每個帳戶真正需要的；例如，智慧合約代碼僅適用于智慧合約，但不適用於“簡單” 帳戶。 此外，雖然任何帳戶的主要貨幣的餘額必須非零（例如，基礎工作鏈的主鏈和分片鏈的Grams），但其他貨幣的餘額可能為零。為了避免保留未使用的資料，（在工作鏈的創建期間）我們定義了一個sum-product類型（取決於工作鏈），它使用不同的標記位元組（例如，TL 構造函數；參見 2.2.5）來區分不同的 “ 構造函數 “使用。最終，帳戶狀態本身被保存為TVM 永久存儲的單元集合。

### 2.4	分片鏈之間的通信
TON 的一個重要組成部分是區塊鏈之間的消息傳遞系統。包括相同工作鏈的下的分片鏈和不同工作鏈下的分片鏈。

#### 2.4.1	消息，帳戶和交易：系統的一種鳥瞰視角下的。
消息從一個帳戶發送到另一個帳戶。 一個交易包含：一個接收一條消息的帳戶、這個帳戶根據某些規則更改其狀態、以及向其他帳戶生成多個（可能是一個或零個）新消息。 每條消息僅會被生成並被接收（傳遞）一次。
這意味著消息在系統中起著至關重要的作用，與帳戶（智慧合約）相當。 從無限分片範式
（參見 2.1.2）的角度來看，每個帳戶都在其獨立的 “帳戶鏈” 中，並且它影響其他帳戶狀態的唯一方法是發送消息。

#### 2.4.2	作為流程或參與者的帳戶；Actor 模型。
有人可能會將帳戶（和智慧合約）視為 “processes” 或 “actors”，它們能夠處理傳入的消息， 更改其內部狀態並生成一些出站消息。 這與所謂的 Actor 模型密切相關，在 Erlang 等語言中使用（然而，Erlang 中的 actor 通常稱為 “processes”）。 由於處理入站消息的結果也允許現有參與者創建新的actors（即，智慧合約），因此與 Actor 模型的對應基本上是完整的。

#### 2.4.3	消息接收者。
任何消息都有其接收者，其特徵是目標工作鏈識別字 w（預設情況下假定與發起的分片鏈一致）和收件方帳戶 account_id。 account_id 的確切格式（即位元組數位）取決於 w； 但是，分片始終由其首位（最重要的）64 位元組確定。

#### 2.4.4	消息發送者。
 
在大多數情況下，消息具有發送者，再次由（w'，account_id'）對表示。它位於消息接收者和消息值之後。  有時，發送者不重要或者是在區塊鏈系統之外（即，並非一個智慧合約），在這種情況下，該欄位不存在。
請注意，Actor 模型不要求消息具有隱式發送者。 相反，消息可以包含對應該發送請求答案的Actor 的引用； 通常它與發送者一致。 但是，在加密貨幣（拜占庭）環境中的消息中具有不可偽造發送者簽名欄位是有用的。

#### 2.4.5	消息值。
消息的另一個重要特徵是其附加值，它在由源（source）和目標工作鏈支援的一個或多個代幣中。 消息的值緊接著消息接收者之後顯示； 它本質上是（currency_id，value）對的列表。請注意，“簡單（simple）” 帳戶之間的 “簡單” 值轉移只是空（無操作）消息，並附加了一些值。 另一方面，稍微複雜的消息體可能包含簡單的文本或二進位注釋（例如，關於支付的目的）。

#### 2.4.6	“來源不明的消息（messages from nowhere）”。
一些“來源不明的消息”會進入系統——也就是說，它們不是由位於區塊鏈中的帳戶（智慧合約或非智能合約）生成的。一個典型的例子是當用戶想要將一些資金從她控制的帳戶轉移到其他帳戶時，這種情況就會發生。在這種情況下，使用者將一條“來源不明的消息”發送到她自己的帳戶，請求它生成帶有指定值的接收帳戶的消息。如果此消息已正確簽名，則她的帳戶會收到該消息並生成所需的出站消息。

實際上，人們可能會將一個 “簡單” 帳戶視為具有預定義代碼的智慧合約的特例。這個智慧合約只收到一種消息。這樣的入站消息必須包含由於傳遞（處理）入站消息而生成的出站消息清單以及簽名。智慧合約檢查簽名，如果正確，則生成所需的消息。

當然，“來源不明的消息”與正常資訊之間存在差異，因為“來源不明的消息”不能承擔附加值， 因此它們不能自行支付它們的 “Gas”（即它們的processing）。相反，在被包含在一個新的分片區塊之前，它們在有一個小額gas限制的條件下執行；如果執行失敗（簽名不正確），則外部消息被認為是不正確的並被丟棄。如果在執行有小額gas限制的進程時沒有失敗，則消息可以被包含在新的分片區塊中進行完全處理，並從從接收者的帳戶中支取（處理任務所需要的） Gas。“來源不明的消息”還可以定義一些除了用於重新分配給驗證人的gas費用之外的交易費用，它們是從接收方的帳戶中被抵扣。

從這個意義上說，外部消息是來自其他區塊鏈系統（例如，比特幣和乙太坊）的交易候選人。

#### 2.4.7	日誌（Log）消息，或 “去向不定的消息（messages to nowhere）”。
類似地，有時可以生成特殊消息並將其導到特定的分片鏈，而不是將其傳遞給其接收者。為了易於任何對接收到的分片更新有疑問的人可觀察，這些消息被記錄下來。這些記錄的消息可以在使用者的控制台中輸出，或者在離線伺服器上觸發某些腳本的執行。 從這個意義上說，它們代表了 “區塊鏈超級電腦” 的外部 “輸出”，就像 外部消息代表 “區塊鏈超級電腦” 的外部
“輸入” 一樣。

#### 2.4.8	與鏈下服務和外部區塊鏈互動。
這些外部輸入和輸出消息可用於與鏈下服務和其他（外部）區塊鏈（如比特幣或乙太坊）進行交互。 有人可能會在 TON 區塊鏈內部創建代幣或加密貨幣，並與比特幣、乙太坊或乙太坊區
 
塊鏈中定義的任何 ERC-20 代幣掛鉤，並使用由腳本生成和處理駐留在某些協力廠商鏈下伺服器上的外部消息和 “去向不定的消息”，以實現 TON區塊鏈與這些外部區塊鏈之間的交互。

#### 2.4.9	訊息文字。
訊息文字只是一個位元組序列，其含義僅由接收工作鏈和（或）智慧合約的確定。 對於使用TON VM 的區塊鏈，這可以是通過 Send()操作自動生成的任何 TVM cell 的序列化。 簡單地通過用所引用的 cell 遞迴地替換 TON VM cell 中的所有引用來獲得這種序列化。 最終，出現一串原始位元組，通常由 4 位元組 “消息類型” 或 “消息構造函數” 預先設置，用於選擇接收智慧合約。
另一種選擇是使用 TL 序列化物件（參見 2.2.5）作為消息體。 這對於不同工作鏈之間的通信尤其有用，也許某個工作鏈不使用 TON VM。

#### 2.4.10	Gas 限制和其他工作鏈 / VM 特定參數。
有時，消息需要攜帶有關gas限制、gas價格、交易費用以及依賴於接收工作鏈的類似值的資訊，並且僅與接收工作鏈相關，但對於原始工作鏈而言並非必要。 這些參數包含在消息體中或之前，有時（取決於工作鏈）具有特殊的 4 位元組首碼，表明它們的存在（可以通過 TL 方案定義；參見 2.2.5）。

#### 2.4.11	創建消息：智慧合約和交易。
這兩個新消息的來源。 大多數消息是在智慧合約執行期間（通過 TON VM 中的 Send()操作） 創建的，此時調用某個智慧合約來處理傳入消息。消息也可能來自外部，作為 “外部消息” 或 “去向不定的消息”（參見 2.4.6）14

#### 2.4.12	傳遞資訊。
當消息到達包含其目標帳戶的分片鏈時，它將 “傳遞（delivered）” 到其目標帳戶15。 接下來會發生什麼取決於工作鏈； 從外部的角度來看，重要的是這樣的消息永遠不能從這個分片鏈進一步轉發。

對於基礎工作鏈的分片鏈，交付包括將附帶數值（減去任何 gas 支付）添加到接收帳戶的餘額，如果收款帳戶是智慧合約則根據消息的規則來調用。實際上，智慧合約只有一個用於處理所有傳入消息的入口點，它必須通過查看它們的前幾個位元組來區分不同類型的消息（例如，包含 TL 構造函數的前四個位元組；參見 2.2.5 ）。

#### 2.4.13	消息的傳遞是一種交易。
因為消息的傳遞改變了帳戶或智慧合約的狀態，所以它是接收分片鏈中的特殊“交易”。忽略細節的話，基本上所有 TON 區塊鏈交易都是向接收帳戶（智慧合約）發送一個入站消息。

#### 2.4.14	同一智慧合約實例之間的消息。
回想一下，智慧合約可能是本地的（即，像任何普通帳戶一樣駐留在一個分片鏈中）或全域的
（即，在所有分片中具有實例，或者至少在所有分片中具有某個已知深度 d；參見 2.3.18）。

---

14   只有基本工作鏈及其分片鏈才能真正實現上述要求。 其他工作鏈可能提供其他創建消息的方法。
15  作為一個退化的案例，這個分片鏈可能與原始的分片鏈重合 - 例如，如果我們在一個尚未拆分的工作
鏈內工作。

--- 

如果需要，全域智慧合約的實例可以交換特殊消息以在彼此之間傳遞資訊和價值。 在這種情況下，（不可偽造的）寄件者 account_id 變得很重要（參見 2.4.4）。

#### 2.4.15	發送給智慧合約任何實例的消息；萬用字元地址。
有時，消息（例如，用戶端請求）需要被傳遞到全域智慧合約的所有實例，通常是最接近的
（例如，如果存在與發送者相同的分片鏈中的一個，則它是明顯的候選者）。 一種方法是使用 “萬用字元接收者位址wildcard recipient address”，允許目標 account_id 的前 d 位元採用任意值。 實際上，通常會將這些 d 位設置為與發送方的 account_id 中相同的值。

#### 2.4.16	輸入佇列不存在。
區塊鏈（通常是分片鏈；有時是主鏈）接收的所有消息——或者基本上由駐留在某個 分片鏈內的 “帳戶鏈account-chain”——立即傳遞（即，由接收帳戶處理）。 因此，沒有 “輸入佇列input queue”。 相反，如果由於區塊總大小和 Gas 使用的限制，並非所有發往特定分片鏈的消息都可以被處理，一些消息只會在原始分片鏈的輸出佇列中堆積。

#### 2.4.17	輸出佇列。
從無限分片範例（參見 2.1.2）的角度來看，每個帳戶鏈（即每個帳戶）都有自己的輸出佇列
，包括它已生成但尚未發送給接收者的所有消息。 當然，帳戶鏈只有虛擬存在； 它們被分組為不同的分片鏈，而分片鏈有一個輸出 “佇列queue”，它由屬於分片鏈的所有帳戶的輸出佇列的並集組成。
此分片鏈輸出 “佇列（queue）” 僅對其成員消息強加部分順序。 也就是說，必須在後續塊中生成的任何消息之前提供在前一個區塊中生成的消息，並且必須按照它們生成的順序傳送由同一帳戶生成並具有相同目的地的任何消息。

#### 2.4.18	可靠，快速的鏈間消息傳遞。
對於像 TON 這樣的可擴展多區塊鏈項目來說，能夠在不同的分片鏈之間轉發和傳遞消息（參見 2.1.3）至關重要。即使系統中有數百萬消息在傳遞，它們也可以被可靠且快速地傳送（即
，消息不應丟失或傳送不止一次）。 TON 區塊鏈通過結合使用兩個 “消息路由（message routing）” 機制實現了這一目標。

 
#### 2.4.19	超立方體路由（Hypercube routing slow path”。
 
“慢速路徑
 

TON 區塊鏈使用 “超立方體路由（Hypercube routing）” 作為一種緩慢但安全可靠的方式，將消息從一個分片鏈傳遞到另一個分片鏈，如有必要，可使用多個中間分片鏈進行傳輸。否則， 任何給定的分片鏈的驗證人都需要追蹤所有其他分片鏈的狀態（輸出佇列），這將需要大量的算力和網路頻寬，因為分片鏈的總量增長，反而限制了系統的可擴展性。因此，無法直接從任何分片向其他分片傳遞消息。相反，每個分片僅 “連接（connected）” 到不同於其(w,s)分片識別字的一個十六進位數字的分片（參見 2.1.8）。這樣，所有的分片鏈都構成了一個 “超立方體（hypercube）” 圖形，並且消息沿著這個超立方體的邊緣傳播。
 
如果將消息發送到與當前分片不同的分片，則當前分片識別字的一個十六進位數字（決定性選擇）將被目標分片的相應數位替換，並且所得到的識別字將通過消息發給最近的目標。16

超立方體路由的主要優點是區塊有效性條件意味著創建分片鏈區塊的驗證人必須收集並處理來自 “相鄰（neighboring）” 分片鏈的輸出佇列的消息，以免丟失它們的抵押。 通過這種方式， 可以預期任何消息遲早會到達其最終目的地； 消息也不能在傳輸過程中丟失或接受兩次。

請注意，超立方體路由引入了一些額外的延遲和費用，因為必須通過幾個中間的分片鏈轉發消息。 然而，這些中間分片鏈的數量增長非常緩慢，如對數鏈 N 的總數的對數 log N（更確切的說 [log16 N]-1）。例如，如果 N≈250，則最多只有一個中間跳； 對於 N≈4000 個 分片鏈， 最多兩個。 通過四個中間躍點，我們可以支援多達一百萬個分片鏈。 我們認為這對於系統的 基本無限可擴展性來說是一個非常小的代價。

#### 2.4.20	“快速路徑（fast path）”。
TON 區塊鏈的一個新特點是它引入了一條 “快速路徑”，用於將消息從一個分片鏈轉發到任何其他分片鏈，允許在大多數情況下完全繞過 2.4.19 的 “慢（slow）” 超立方體路由，並將消息傳遞到最後一個目的地分片鏈的下一個區塊。

這個想法如下：在 “慢slow” 超立方體路由期間，消息沿著超立方體的邊緣（在網路中）傳播， 但是在每個中間頂點處被延遲（大約五秒）以在繼續其航行之前被提交到相應的分片鏈中。

為了避免不必要的延遲，可以使用沿超立方體邊緣的合適的 Merkle 證明來中繼消息，而無需等待將其提交到中間的分片鏈中。實際上，網路消息應該從原始分片的 “任務組（task group
）”（參見 2.6.8）的驗證人轉發到目的地 “任務組” 的指定分片區塊生成器（參見 2.6.9）。這可以直接完成，而不需要沿著超立方體的邊緣。當帶有 Merkle 證明的消息到達目的地分片鏈的驗證人（更確切地說，校對人[collators]；參見 2.6.5）時，它們可以立即將其提交到新的區塊中，而無需等待消息完成其沿著 “慢速路徑（slow path）”。然後沿著超立方體邊緣發送回傳送確認以及合適的 Merkle 證據，並且可以通過提交特殊交易來用於沿著 “慢速路徑” 停止消息的行進。

請注意，這種 “即時交付（instant delivery）” 機制並不能取代 2.4.19 中描述的 “慢速”但防止故障的機制。因為驗證人不會因丟失或僅僅決定不將 “快速路徑” 消息提交到其區塊鏈的新區塊而受到懲罰， “慢速路徑”仍被需要17。

因此，兩種消息轉發方法並行運行，只有在將 “快速” 機制的成功證明提交到中間分片鏈時才會中止 “慢速” 機制。18

#### 2.4.21	從相鄰分片鏈的輸出佇列收集輸入消息。
當提出用於分片鏈的新區塊時，鄰近的一些輸出消息（如 2.4.19 的路由分支所示）分片鏈作為 “輸入（input）” 消息包含在新塊中並立即傳送（即處理）。 處理這些臨近的輸出消息的順序，會存在一些規則。 基本上來說，必須在任何 “較新（newer）” 消息之前，先傳遞 “較舊（

---

16這不一定是用於計算超立方體路由的下一跳的演算法的最終版本。 特別地，十六進位數位可以由r比特
組代替，其中r是可配置參數，不一定等於4。
17 但是，驗證人有一些動機儘快這樣做，因為他們將能夠收集與慢速路徑上尚未消耗的消息相關的所有
轉發費用。
18 事實上，人們可能暫時或永久地完全禁用“即時交付”機制，系統將繼續工作，儘管速度較慢。

---

older）” 消息（來自指向較舊主鏈區塊的分片鏈的區塊）； 對於來自相同相鄰分片鏈的消息， 必須遵守 2.4.17 中描述的輸出佇列的部分順序。

#### 2.4.22	從輸出佇列中刪除消息。
一旦觀察到輸出佇列消息已經被相鄰的分片鏈傳遞，它就會被特殊交易從輸出佇列中顯式刪除。

#### 2.4.23	防止雙重傳遞消息。
為了防止從相鄰分片鏈的輸出佇列中獲取的消息的傳輸兩次，每個分片鏈（更確切地說，其中的每個帳戶鏈）將最近傳遞的消息（或僅僅是它們的雜湊）的集合保存為其狀態的一部分。當觀察到傳遞的消息由其始發的相鄰分片鏈從輸出佇列中刪除時（參見  2.4.22），它也會從最近傳遞的消息的集合中刪除。

#### 2.4.24	轉發用於其他分片鏈的消息。
超立方體路由（參見 2.4.19）裡有時出站消息不會傳遞到包含預期接收者的分片鏈，而是傳遞到位於到目的地的超立方體路徑上的相鄰分片鏈。這種情況下，“傳遞（delivery）” 包括將入站消息移動到出站佇列。這在區塊中具體顯示為包含消息本身的特殊轉發事件。從本質上講， 這看起來好像是分片鏈中的某個人收到了消息，並且結果生成了一條相同的消息。

#### 2.4.25	為轉發和保留消息支付。
轉發交易實際上花費了一些 gas（取決於轉發的消息的大小），因此將從代表該分片鏈的驗證人轉發的消息的數值中扣除 gas費用。這種轉發支付通常遠小於當消息最終傳遞給其接收者時所支付的 gas 支付，即使該消息由於超立方體路由而被多次轉發。此外，只要消息保存在某個分片鏈的輸出佇列中，它就是分片鏈全域狀態的一部分，因此特殊交易也可以收集長時間保存全域資料的支付。

#### 2.4.26	來自主鏈的消息。
消息可以直接從任何分片鏈發送到主鏈，反之亦然。但是，在主鏈中發送消息和處理消息的gas 價格非常高，因此只有在真正需要時才會使用此功能——例如，驗證人可以存入他們的抵押中。在一些情況下，可以定義發送到主鏈的消息的最小抵押（附加值），僅當消息被接收方視為 “有效（valid）” 時才返回。

消息無法通過主鏈自動路由。workchainid = 1 的消息（1 是表示主鏈的特殊 workchainid）無法傳遞給主鏈。

原則上，可以在主鏈內創建消息轉發智慧合約，但使用它的價格會很高。

#### 2.4.27	同一個分片鏈中的帳戶之間的消息。
在某些情況下，消息由屬於某個分片鏈的帳戶生成，發往同一個分片鏈中的另一個帳戶。例如
，這發生在一個尚未拆分為多個分片鏈的新工作鏈中，因為負載可控。

此類消息可能會累積在分片鏈的輸出佇列中，然後作為後續塊中的傳入消息進行處理（為此目的，任何分片都被視為臨近分片）。但是，在大多數情況下，可以在原始區塊鏈自身之內傳遞這些消息。
 
為了實現這一點，將對一個分片鏈區塊中包括的所有交易強加上一個偏序，並且根據這個偏序來處理這些交易（每個交易包括向某個帳戶傳遞消息）。特別是，一項交易可以處理關於這一偏序的一些輸出消息。

在這種情況下，訊息文字不會被複製兩次。相反，始發和處理交易會參考消息的副本。

### 2.5	分片鏈的全域狀態。 “Bag of Cells”
現在我們準備描述TON區塊鏈的全域狀態，或者基礎工作鏈的分片鏈。我們從 “高級（
high-level）” 或 “邏輯（logical）” 描述開始，其中包括全域狀態是代數類型 ShardchainState
的值。

#### 2.5.1	分片鏈狀態作為帳戶鏈狀態的集合。
根據“無限分片範式”（參見 2.1.2），任何分片鏈只是一個（臨時）虛擬 “帳戶鏈” 集合，每個只包含一個帳戶。這意味著，本質上，全域分片鏈狀態必須是一個hashmap。

ShardchainState := (Account AccountState) (23)

如果我們正在討論分片的狀態(w,s)（參見 2.1.8），那麼所有出現在這個hashmap索引中的account_id 必須以首碼 s 開頭。

實際上，我們可能希望將 AccountState 分成幾個部分（例如，將帳戶輸出訊息佇列分開以簡化相鄰分片鏈的驗證），並在 ShardchainState 內部有幾個hashmap（Account ➔ FountStateParti）。我們還可以向 ShardchainState 添加少量 “全域” 或 “整數” 參數（例如， 屬於該分片的所有帳戶的總餘額，或所有輸出佇列中的消息總數）。從 “邏輯”（“高級”）的角度來看，（23）是分片鏈全域狀態看起來的良好的第一步。AccountState 和 ShardchainState 形式描述的欄位可以借助 TL 方案（參見 2.2.5）完成。

#### 2.5.2	拆分和合併分片鏈狀態。
請注意，分片鏈狀態（23）的無限分片範例描述顯示了在分割或合併分片時應如何處理此狀態。實際上，這些狀態轉換結果是使用hashmap的操作，非常簡單。

#### 2.5.3	帳戶鏈狀態。
（虛擬）帳戶鏈狀態只是一個帳戶的狀態，由 AccountState 欄位來描述。 通常它具有 2.3.20
中列出的全部或部分欄位，具體取決於所使用的具體構造函數。

#### 2.5.4	全域工作鏈狀態。
與（23）類似，我們可以通過相同的公式定義全域工作鏈狀態，但允許使用 account_id 獲取任何值，而不僅僅是一個分片的值。 類似於 2.5.1 中的注釋也適用於這種情況：我們可能希望將該hashmap拆分為幾個hashmap，我們可能希望添加一些 “整數（integral）” 參數，例如總餘額。
 
本質上，全域工作鏈狀態必須由 和分片鏈狀態同類型的ShardchainState 給出，因為如果此工作鏈的所有現有的分片鏈合併為一個，我們將會獲得分片鏈的狀態。

#### 2.5.5	Low-level （低級）來看：“Bag of Cells”。
帳戶鏈或分片鏈狀態的 “低級（low-level）” 描述也是對上面給出的 “高級（high-level）” 描述的補充。這個描述非常重要，因為它非常普遍，為通過網路去表示、存儲、序列化和傳輸TON 區塊鏈所使用的幾乎所有資料，提供了通用基礎（區塊、分片鏈狀態、智慧合約存儲、Merkle 證明等）。同時，這種普遍的 “低級” 描述一旦被理解和實施，就可以使我們只關注
“高級” 來考慮。

回想一下，TVM 通過 TVM cells樹或簡稱cells（參見 2.3.14 和 2.2.5）表示任意代數類型的值
（例如，包括（23）的 ShardchainState）。

任何這樣的cell由兩個描述符位元組組成，定義了某些標誌和值 0≤b≤128，原始位元組數，0≤c≤4
，即對其他cell的引用數量。然後是 b 原始位元組和 c cell引用。19

Cell引用的確切格式取決於實現以及cell是位於 RAM中，還是磁片、網路資料包、區塊中等等。一個有用的抽象模型在於想像所有cells都保存在內容可定址的記憶體中，cells的位址等於其
（sha256）雜湊。回想一下，一個cell的（Merkle）雜湊是通過用它（遞迴計算的）雜湊替換對其子cells的引用，並對生成的位元組串進行雜湊化來精確計算。

以這種方式，如果我們使用cells的雜湊來引用cells（例如，其他cells的內部描述），則系統稍微簡化，並且一個cell的雜湊開始與表示它的位元組串的雜湊重合。

現在我們看到 TVM 表示的任何物件，包括全域分片鏈狀態，可以表示為 “bag of cells”——例如，一組cells及對其中一個的 “根（root）” 引用（例如，通過雜湊） 。請注意，從此描述中刪除了重複的cells（“bag of cells” 是一組cells，而不是多重集合的細胞[a multiset of cells]）
，因此抽象樹表示可能實際上成為有向無環圖（DAG）表示。

有人甚至可能將這種狀態保存在 B-或 B + -tree 的磁片上，包含所有相關的cells（可能帶有一些額外的資料，如子樹高度或參考計數器），由cell雜湊索引。然而，這種想法的天真實現將導致一個智慧合約的狀態分散在磁片檔的遠端部分，我們寧願避免它。20

現在我們將詳細解釋 TON 區塊鏈所使用的幾乎所有物件如何表示為一個“bag of cells”，從而
證明這種方法的普遍性。

#### 2.5.6	分片鏈的區塊作為 “Bag of Cells”。
分片鏈的區塊本身也可以用代數類型描述，並存儲為一個 “bag of cells”。然後，可以簡單地通過以任意順序連接表示一個 “bag of cells”中每個cell的位元組串來獲得塊的樸素二進位表示。例如，通過在區塊頭提供所有cell的偏移列表，並且盡可能將該列表中具有 32 位元索引的其他

---

19 可以證明，如果同樣經常需要存儲在cells樹中的所有資料的Merkle樣張，則應該使用具有b +ch≈2（h
+ r）的cell來最小化平均Merkle校樣大小，其中h = 32是 散列大小（以位元組為單位），r≈4是cell引用的“位元組大小”。 換句話說，一個cell應該包含兩個引用和一些原始位元組，或者一個引用和大約36個原始位元組，或者根本不包含72個原始位元組的引用。
20 一種更好的實現是將智慧合約的狀態維持序列化字串（如果它很小），或者保存在單獨的B樹中
（如果它很大）; 那麼代表區塊鏈狀態的頂級結構將是一個B樹，其葉子允許包含對其他B樹的引用。
 
cells的雜湊引用替換為該表示，可以改進和優化該表示。然而，人們應該想像一個塊本質上是一個 “bag of cells”，所有其他技術細節只是次要的優化和實現問題。

---

#### 2.5.7	“Bag of Cells” 的對象。
想像一下，我們有一個舊版本的某個物件表示為 “bag of cells”，我們想要代表同一個物件的新版本，據說與前一個物件沒有太大差別。人們可能只是將新狀態表示為具有其自身根的另一個“bag of cells”，並從中移除舊版本中出現的所有cell。剩下的 “bag of cells” 本質上是物件的更新。擁有此物件的舊版本和更新的每個人都可以計算新版本，只需將兩組cells聯合起來，然後刪除舊的根（如果引用計數器變為零，則減少其引用計數器並取消分配cell） 。

#### 2.5.8	更新帳戶狀態。
可以使用 2.5.7 中描述的思想來表示對帳戶狀態, 或分片鏈的全域狀態或任何hashmap的更新。 這意味著當我們收到一個新的分片鏈區塊（這是一個 “bag of cells”）時，我們不僅僅是單獨解釋這個 “bag of cells”，而是首先將它與代表分片鏈前一狀態的 “bag of cells” 結合起 來。 在這個意義上，每個塊可以 “包含（contain）” 區塊鏈的整個狀態。

#### 2.5.9	區塊的更新
回想一下，一個區塊本身就是一個 “bag of cells”，因此，如果有必要編輯一個區塊，可以類似地將 “區塊更新（block update）” 定義為 “bag of cells”。在 “bag of cells”的情況下進行解釋， 則是該區塊的先前版本。這大致是 2.1.17 中討論的 “垂直塊（vertical blocks）” 背後的想法。

#### 2.5.10	Merkle 證明作為 “Bag of Cells”。
請注意，（廣義）Merkle 證明——例如，一個斷言 x [i] = y 從已知值 Hash（x）= h（參見
2.3.10 和 2.3.15）開始——也可以表示為 “bag of cells”。 也就是說，只需要提供一個cells的子集，該子集對應於從 x：Hashmap（n，X）的根到其所需分支的路徑，其索引為 i:2x和值y:X。對不處於該路徑上的這些cells的子集的引用，將在該證明中保持“未解析”，由cell雜湊表示。還可以提供同步的Merkle證明，如，x [i] = y和x [i'] = y'，通過包括在“bag of cells”中的cells，它們位於從x的根到對應於索引i和i'的葉子的兩條路徑的並集上。

#### 2.5.11	Merkle 證明作為全節點的回應。
實質上，具有分片鏈（或帳戶鏈）狀態的完整副本的完整節點可以在輕節點（例如，運行TON 區塊鏈用戶端的輕節點）請求時提供 Merkle 證明，從而僅使用此 Merkle 證明中提供的cells，啟用接收器在沒有外部説明的情況下執行一些簡單的查詢。輕節點可以將序列化格式的查詢發送到整個節點，並通過 Merkle 證明或 Merkle 證明接收正確答案，因為請求者應該只能使用 Merkle 證明中包含的cells來計算答案。這個 Merkle 證明只包含一個 “bag of cells”， 只包含那些屬於分片鏈狀態的cells，這些cells在執行輕節點查詢時已被完整節點訪問。這種方法尤其可用于執行智慧合約的 “獲取查詢（get queries）”（參見 4.3.12）。

#### 2.5.12	用 Merkle 有效證明增強更新和狀態更新。
回想一下（參見 2.5.7），我們可以從舊值（old value）x來描述物件狀態的變化：從X到一個新值（new value）x'：X通過一次“更新（update）”，它只是“bag of cells”，包含代表新值的子樹中的那些cell x'，但不在表示舊值 x 的子樹中，因為假定接收器具有舊值 x 及其所有cells 的副本。
 
但是，如果接收器沒有 x 的完整副本，但只知道它的（Merkle）雜湊 h = Hash（x），它將無法檢查更新的有效性（即，所有 “dangling”cell更新中的引用確實引用 x）樹中的細胞。人們希望得到 “可驗證的（verifiable）” 更新，並通過 Merkle 證明舊狀態中所有被引用的細胞的存在。然後任何只知道 h = Hash（x）的人都能夠檢查更新的有效性並自己計算新的 h'= Hash（ x'）。

因為我們的 Merkle 證明本身就是 “bag of cells”（參見 2.5.10），所以可以將這樣的增強更新構建為 “bag of cells”，其中包含 x 的舊根，其中的一些後代以及來自 x 的根到它們，以及 x' 的新根和它不屬於 x 的所有後代。

#### 2.5.13	分片鏈區塊中的帳戶狀態更新。
應如 2.5.12 中所討論的那樣，擴充分片鏈區塊中的帳戶狀態更新。 否則就有人可能會提交一個包含無效狀態更新的塊，例如舊狀態中缺少某個cell； 證明這種阻滯無效將是有問題的（質疑者將如何證明一個cell不屬於先前的狀態？）。

現在，如果塊中包含的所有狀態更新都得到了增強，則很容易檢查它們的有效性，並且它們的無效性也很容易顯示為違反（廣義）Merkle 雜湊的遞迴定義屬性。

#### 2.5.14	“Bag of Cells”
先前的考慮表明，我們需要在 TON 區塊鏈或網路中存儲或傳輸的所有內容都可以表示為 “bag of cells”。這是 TON 區塊鏈設計理念的重要組成部分。一旦解釋了 “Bag of Cells” 方法並定義了 “bag of cells” 的一些 “low-level” 序列化，就可以在高層次簡單抽象定義出（依賴）代數資料類型的所有內容（區塊格式，分片鏈和帳戶狀態等）。“萬物皆a bag of cells” 統一的理念， 大大簡化了看似無關的服務的實施（比如 5.1.9 舉例涉及支付通道）。

#### 2.5.15	TON 區塊鏈的區塊“頭（header）”。
通常，區塊鏈中的一個區塊以小頭開始，包含前一個區塊的雜湊，它自身的創建時間，區塊鏈中包含的所有交易的樹的 Merkle 雜湊，等等。然後將區塊雜湊定義為該小頭的雜湊。因為區塊頭最終取決於區塊中包含的所有資料，所以不能在不改變其雜湊的情況下改變區塊。

在 TON區塊鏈的區塊使用的 “bag of cells” 方法中，沒有指定的區塊頭。相反，區塊雜湊被定義為區塊的根cell的（Merkle）雜湊。因此，區塊鏈的頂部（根）cells可能被認為是該區塊的小 “頭（header）”。

但是，根cell可能不包含通常從這種區塊頭中預期的所有資料。實質上，需要區塊頭包含區塊資料類型(Block datatype)中定義的一些欄位。通常，這些欄位將包含在幾個cells中，包括根目錄。這些是共同構成所討論的欄位值的 “Merkle 證明” 的cells。有人可能會在任何其他cells 之前一開始就堅持要求一個區塊鏈包含這些 “header cells”。然後只需要下載區塊序列化的前幾個位元組，以獲得所有“header cells”，並知道所有預期的欄位。

### 2.6	創建和驗證新的區塊。
TON 區塊鏈最終由分片鏈和主鏈區塊組成。為了保障系統平穩運行，這些區塊必須通過網路來創建、驗證並其傳播給所有相關方。
 
#### 2.6.1	驗證人（Validator）。
新區塊由特殊的指定節點（稱為驗證人）創建和驗證。基本上，任何希望成為驗證人的節點都可以成為一個驗證人，只要它能夠將足夠大量的質押資產（在 TON 代幣中，即 Grams；參見附錄 A）存入主鏈。 驗證人因其出色的工作而獲得了一些 “獎勵”，也就是說，所有來自交易
（消息）、存儲和 gas的費用都被投入到新生成的區塊和一些新鑄造的幣中，這反映了整個社區對保證 TON Blockchain 平穩運作的的驗證人的“感激（gratitude）”該收入按比例分配給所有參與的驗證人。

然而，作為驗證人是一項高度責任。如果驗證人簽署了無效區塊，則會迎來通過丟失部分或全部質押資產的處罰，並暫時或永久地從驗證人集合中排除。如果驗證人不參與創建區塊，則不會收到與該區塊相關的獎勵份額。如果驗證人長期放棄創建新區塊，它可能會丟失部分質押資產，並被暫停或永久排除在驗證人集合之外。

所有這一切都意味著驗證人不會 “什麼都不做” 就賺到錢。實際上，它必須追蹤所有或一些分片鏈的狀態（每個驗證人負責驗證和創建分片鏈某個子集中的新區塊），執行這些分片鏈中智慧合約請求的所有計算，接收有關其他的更新分片鏈等。該活動需要相當大的存儲空間、算力和網路頻寬。

#### 2.6.2	驗證人（Validator）代替礦工（Miner）。
回想一下，TON區塊鏈使用的是共識演算法是 POS，而不是POW這種被當前版本的乙太坊以及大多數其他加密貨幣採用的工作量證明方法。這意味著人們不能通過提供一些證明工作（計算許多其他無用的雜湊）來 “挖（mine）” 一個新的區塊，並因此獲得一些新的幣。相反，人們必須成為驗證人，並花費計算資源來存儲和處理 TON 區塊鏈的請求和資料。簡而言之，某人如果想要開採新的代幣，則必須成為驗證人。這樣一來，驗證人就是新的礦工。

然而，除了成為驗證人外，還有其他一些方法來賺幣。

#### 2.6.3	提名人（Nominator）和 “mining pools（礦池）”
要成為驗證人，需要購買並安裝多個高性能伺服器並需要維持良好穩定網路連接。這並不像目前開發比特幣所需的 ASIC 設備那麼昂貴。然而，絕對不能在家用電腦上挖掘新的 TON代幣
，更別提智能手機了。

在比特幣，乙太坊和其他工作量證明加密貨幣挖掘社區中，有一個挖掘池的概念，挖掘池其中
許多節點個體不具由挖掘新區塊的計算能力，但他們團結在一起努力並在之後分享獎勵。

這對應在權益證明世界中的相應概念則提名人。從本質上講，這是一個節點借錢來幫助驗證人增加其抵押物；驗證人然後將其獎勵的相應份額（或之前商定的一部分——比如 50％）分配給提名人。

通過這種方式，提名人也可以參與 “挖礦（mining）” 並獲得與其願意為此目的存入的金額成比例的一些獎勵。它僅獲得驗證人獎勵的相應份額的一小部分，因為它僅提供 “資本（capital
）”，但不需要購買計算能力，存儲和網路頻寬。
 
但是，如果驗證人因無效行為而失去其抵押物，則提名人也會失去其抵押物。從這個意義上說
，提名人分擔風險。它必須明智地選擇其指定的驗證人，否則可能會賠錢。從這個意義上說， 提名人做出加權決定，並用他們的資金對某些驗證人進行 “投票（vote）”。

另一方面，這個提名或借出系統使人們能夠成為驗證人，而無需先向 Grams（TON 幣）投入大量資金。換句話說，它可以阻止那些使用大量的 Grams 壟斷驗證人的人。

#### 2.6.4	漁夫（Fisherman）：通過指出別人的錯誤來獲得金錢。
獲得一些獎勵而不是驗證人的另一種方法是成為一名漁夫。基本上，任何節點都可以通過在主鏈中存入少量存款而成為漁夫。然後，它可以使用特殊的主鏈交易來發佈先前由驗證人簽名和發佈的一些（通常是分片鏈）區塊的（Merkle）無效證明。如果其他驗證人同意該無效證明， 則違規驗證人將被處罰（通過丟失部分質押資產），並且漁夫獲得一些獎勵（從違規驗證人處沒收的一小部分幣）。之後，必須按照 2.1.17 中的描述更正無效（分片鏈）塊。糾正無效的主鏈區塊可能涉及在先前提交的主鏈區塊之上創建 “垂直” 塊（參見 2.1.17）；沒有必要創建主鏈的分支。

通常，漁夫需要成為至少一些分片鏈的完整節點，並通過運行至少一些智慧合約的代碼來花費一些計算資源。雖然漁夫不需要具有作為驗證人的計算能力，但我們認為成為漁夫的自然候選人是準備處理新區塊的潛在驗證人，但尚未被選為驗證人（例如，由於未能存放足夠大的抵 押）。

#### 2.6.5	校對人（Collator）：通過給驗證人提供出新區塊的建議來獲得金錢。
另一種獲得一些獎勵而不是驗證人的方法是成為一名校對人。這是一個節點，它準備並向驗證人建議新的分片鏈候選區塊，補充（校對）從該分片鏈的狀態和其他（通常是鄰近的）分片鏈獲取的資料，以及合適的 Merkle 證明。（這是必要的。例如，當某些消息需要從相鄰的分片鏈轉發時。）然後驗證人可以輕鬆地檢查建議的候選區塊的有效性，而無需下載此或其他分片鏈的完整狀態。
因為驗證人需要提交新的（校對後的）候選區塊以獲得一些（“挖礦”）獎勵，所以將一部分獎勵支付給願意提供合適的候選區塊的校對人是有意義的。通過這種方式，驗證人可以通過將其外包給校對人來擺脫觀察相鄰分片鏈狀態的必要性。

但是，我們希望在系統的初始部署階段不會有單獨的指定校對人，因為所有驗證人都可以自己充當校對人。

#### 2.6.6	校對人或驗證人：從説明使用者整合交易中獲取金錢。
用戶可以向一些校對人或驗證人打開小額支付通道，並支付少量幣以換取在分片鏈中包含他們的交易的權利。

#### 2.6.7	選舉全域驗證人人。
每個月選出一組 “全域（global）” 驗證人（主鏈每出 219 個塊選舉一次）。這個設置普遍會被提前一個月確定並被廣泛宣告。

為了成為驗證人，節點必須將一些TON幣（Grams）轉移到主鏈中，然後將它們作為預備的質押資產s發送至一個特殊的智慧合約。與質押資產一起發送的另一個參數是 l ≥1，與可能的
 
最小值比起來，這是該節點願意接受的最大驗證負載。l 還有一個全域上限（另一個可配置參數）參數 L，當 L=10 時，我們把 l 稱為 L。

然後通過這個智慧合約選擇全域驗證人，簡單地通過最大建議質押選擇最多 T 個候選人並公佈它們的身份。最初，驗證人的總數是 T=100；我們預計隨著負載的增加它可能增長到1000
。T是一個可配置參數（參見 2.1.21）。

每個驗證人的實際質押資產計算如下：如果最高的T建議的抵押物是 s1 ≥ s2 ≥···≥ sT，第i個驗證人的實際賭注設置為s’i：= min (si, li·sT)。通過這種方式，s’i / s’T ≤ li，因此第i個驗證人獲得的負載不超過最弱驗證人的li≤L倍（因為負載最終與抵押物成比例）。

然後當選的驗證人可以撤回質押資產中未使用的部分，即si-s’i。未能成功獲選的驗證人候選人可以撤回它們提出的所有建議質押資產。

每個驗證人都發佈其公共簽名金鑰，不一定等於質押資產來源的帳戶的公開金鑰。21

驗證人的質押資產被凍結，直到它們當選的期限結束，或者還有一個月的額外時間，以防出現新的糾紛（即，找到由這些驗證人其中之一簽名的無效塊）。在此之後，將返還質押資產，以及驗證人的鑄幣份額及在此期間處理的交易費用。


#### 2.6.8	“任務組（task groups）”。
全域驗證人（其中每個驗證人被認為擁有的資產遠遠多於質押資產——否則驗證人可能傾向於偽造幾個身份並將自己的質押資產分發給每一個假身份）僅用於驗證新的主鏈區塊。分片鏈區塊僅通過特別選擇的驗證人子集進行驗證，這些驗證人子集取自 2.6.7 中所述選擇的全域驗證人集。
為每個分片定義的這些驗證人 “子集” 或 “任務組” 每小時輪換一次（實際上，每 210 個主鏈區塊輪換一次），並且它們會提前一小時知道，這樣每個驗證人都知道驗證需要哪些分片，並且可以為此做好準備（例如，通過下載丟失的分片鏈資料）。

用於為每個分片（w，s）選擇驗證人任務組的演算法是確定性偽隨機。它使用驗證人嵌入的偽亂數到每個主鏈區塊（由使用閾值簽名的共識生成）來創建隨機種子，然後計算為每個驗證人計算 雜湊，例如（code(w).code(s).validatorid.randseed）。然後驗證人按該雜湊的值進行排序，並選擇前幾個驗證人，以便至少具有驗證人總質押資產的 20 / T，並且至少包含 5 個驗證人。

這種選擇可以通過特殊的智慧合約來完成。在這種情況下，選擇演算法很容易升級，而不需要
2.1.21 中提到的投票機制的硬分叉。到目前為止提到的所有其他 “常量（constants）” （例如
219, 210, T, 20, 和 5）也是可配置參數。

#### 2.6.9	在每個任務組上輪換優先順序順序。
根據先前主鏈區塊和（分片鏈）區塊序號的雜湊，  對於分片任務組的成員而言具有一定的
“優先順序（priority）” 順序。如上所述，該順序通過生成和排序某些雜湊來確定。

---

21 在每個驗證人選舉的過程中，生成和使用金鑰對是有意義的。

---

當需要生成新的分片鏈區塊時，選擇創建該區塊的分片任務組驗證人通常是關於該輪換 “優先順序” 順序中的第一個。如果它無法創建區塊，則第二個或第三個驗證人可以執行該操作。從本質上講，它們都可以推薦它們的候選區塊，但具有最高優先順序的驗證人建議的候選區塊應該作為拜占庭容錯（BFT，Byzantine Fault Tolerant）共識協議的結果而獲勝。

#### 2.6.10	分片鏈候選區塊的傳播。
由於分片鏈任務組成員資格是提前一小時知道的，因此使用 TON網路的一般機制（參見 3.3
），其成員可以利用該時間構建專用的 “分片驗證人多播覆蓋網路（shard validators multicast overlay network）”。當需要生成新的分片鏈區塊時——通常在最近的主鏈區塊傳播後一兩秒鐘——每個人都知道誰具有最高優先順序來生成下一個區塊（參見 2.6.9）。該驗證人將自行或者在校對人的幫助下創建一個新的校對過的候選區塊，（參見 2.6.5）。驗證人必須檢查（驗證）該候選區塊（特別是如果它已由某個校對人準備）並使用其（驗證人）私密金鑰對其進行簽 名。然後使用預先安排的多播覆蓋網路將候選區塊傳播到任務組的其餘部分（任務組創建其自己的專用覆蓋網路，如 3.3 中所述，然後使用 3.3.15 中描述的流式多播協議的版本來傳播候選區塊）。

真正的 BFT 方式是使用一個拜占庭組播協議（Byzantine multicast
protocol），例如 Honey Badger BFT 中使用的協定：用（N，2N / 3）——擦除碼來編碼候選區塊，直接發送 1 / N 結果資料給組裡的每個成員，並期望它們將其部分資料直接組播到組的所有其他成員。

然而，更快更直接的方法（參見 3.3.15）是將候選區塊分成一系列有符號的一千位元組塊（“塊(chunks)”），用 Reed-Solomon 或者一個噴泉碼（例如 RaptorQ 代碼）來增加它們的序列， 並開始向 “組播網格（multicast mesh）”（即覆蓋網路）中的鄰近節點發送區塊，期望它們進一步傳播這些區塊。一旦驗證人獲得足夠的塊以從它們重建候選區塊，它就簽署確認收據並通過其鄰近節點將其傳播到整個組。然後它的鄰近節點停止向它發送新的區塊，但是可以繼續發送這些區塊的（原始）簽名，相信該節點可以通過自己應用 Reed-Solomon 或 噴泉碼（具有所有必要的資料）來生成後續區塊，並將它們與簽名結合起來傳播給尚未準備好的相鄰區塊。如果在刪除所有 “壞” 節點後 “組播網格（multicast mesh）”（覆蓋網路）仍保持連接（回想一下，以拜占庭方式允許多達三分之一的節點是壞的，即以任意惡意方式行事），該演算法將盡可能快地傳播候選區塊。

不僅指定的高優先順序區塊創建者可以將其候選區塊組播到整個組。優先順序第二和第三的驗證人可以立即或在未能從最高優先順序驗證人接收候選區塊之後開始組播它們的候選區塊。但是，通常只有具有最大優先順序的候選區塊將由所有（實際上，至少為任務組的三分之二）驗證人簽名並作為新的分片鏈區塊提交。

#### 2.6.11	驗證候選區塊。
一旦驗證人接收到候選區塊並且檢查了其原始驗證人的簽名，則接收驗證人通過執行其中的所有交易並檢查它們的結果是否與所聲明的一致來檢查該候選區塊的有效性。從其他區塊鏈導入的所有消息必須由校對資料中的合適 Merkle 證明支援，否則候選區塊被視為無效（並且，如果將此證明提交給主鏈，則驗證人已經簽署了此候選區塊則可能會受到懲罰）。另一方面，如果發現候選區塊有效，則接收驗證人對其進行簽名，並通過 “組播網狀網路 （multicast mesh network）” 或直接網路消息將其簽名傳播到該組中的其他驗證人。
 
我們想強調一個驗證人不需要訪問這個或相鄰的分片鏈的狀態，以便檢查（校對的）候選區塊的有效性。22這允許驗證非常快速地進行（沒有磁片訪問），並且減輕驗證人的計算和存儲負擔（特別是如果它們願意接受外部校對人的服務來創建候選區塊者）。

#### 2.6.12	選舉下一個候選區塊。
一旦候選區塊（通過質押）收集任務組中驗證人至少三分之二的有效性簽名，它就有資格被提交為下一個分片鏈區塊。運行 BFT 協議以對所選擇的候選區塊（可能存在多於一個）進行一致，所有 “好” 驗證人優選該輪具有最高優先順序的候選區塊。作為運行該協議的結果，通過至少三個驗證人（通過質押）的簽名來增強該區塊。這些簽名不僅證明了所討論的塊的有效性， 而且證明了它是由 BFT 協議選出的。之後，區塊（沒有校對的資料）與這些簽名組合，以確定的方式序列化，並通過網路傳播給所有相關方。

#### 2.6.13	驗證人必須保留它們簽名過的區塊。
在它們加入任務組及其後至少一個小時（或者更確切地說是 210個塊）期間，驗證人應該保留它們已簽署和提交的塊。未能向其他驗證人提供簽名區塊可能會受到懲罰。

#### 2.6.14	將新分片鏈區塊的塊頭和簽名傳播到所有驗證人。
驗證人使用類似於為每個任務組創建的組播網狀網路，將新生成的分片鏈區塊的區塊頭和簽名傳播到全域驗證人集。

#### 2.6.15	主鏈生成新的區塊。
在生成所有（或幾乎所有）新的分片鏈區塊之後，可以生成新的主鏈區塊。該過程與分片鏈區塊（參見 2.6.12）基本相同，不同之處在於所有驗證人（或至少三分之二）都必須參與此過程。因為新的分片鏈區塊的區塊頭和簽名被傳播至所有驗證人，所以每個分片鏈中最新區塊的雜湊可以且必須包含在新的主鏈區塊中。一旦這些雜湊值被提交到主鏈區塊中，外部觀察者和其他分片鏈可能會認為新的分片鏈區塊已提交且不可變（參見 2.1.13）。

#### 2.6.16	驗證人必須同步主鏈的狀態。
主鏈和分片鏈之間一個值得注意的區別是，所有驗證人都需要追蹤主鏈狀態，而不依賴于校對資料。這很重要，因為驗證人任務組的知識來自主鏈狀態。

#### 2.6.17	分片鏈的區塊是並行生成和傳播的。
通常，每個驗證人都是幾個分片鏈任務組的成員；它們的數量（因此驗證人的負載）大約與驗證人的抵押總比成比例。這意味著驗證人並行運行新的分片鏈區塊生成協定的幾個實例。

#### 2.6.18	區塊保留攻擊的緩解。
因為驗證人的總集合在僅看到其標題和簽名之後將新分片鏈區塊的雜湊值插入主鏈中，所以生成該區塊的驗證人很可能會合謀並試圖避免完整地發佈新區塊。這將導致相鄰分片鏈的驗證人無法創建新區塊，因為一旦將其雜湊值提交到主鏈中，它們必須至少知道新區塊的輸出訊息佇列。

---

22 A可能的例外是相鄰分片鏈的輸出佇列的狀態，需要保證2.4.21中描述的消息排序要求，因為在這種情況下Merkle樣張的大小可能變得過高。

---

為了緩解這種情況，新區塊必須收集來自其他驗證人的簽名（例如，相鄰分片鏈的任務組加起來的三分之二），證明這些驗證人確實具有該區塊的副本並且願意將它們發送給其他其他驗證人。只有在這些簽名出現後，新區塊的雜湊才能包含在主鏈中。

#### 2.6.19	主鏈區塊比分片鏈區塊生成更晚。
主鏈區塊大約每五秒生成一次，分片鏈區塊也是如此。 然而，雖然所有分片鏈中的新區塊生成基本上同時（通常由新的主鏈區塊的釋放觸發），但是故意延遲生成新的主鏈區塊是為了允許包含主鏈中新生成的分片鏈區塊新的雜湊值。

#### 2.6.20	慢的驗證人可能收到較低的獎勵。
如果驗證人動作“慢”，則可能無法驗證新的候選區塊，並且可以在沒有其參與的情況下收集提交新塊所需的簽名的三分之二。 在這種情況下，它將獲得與此塊相關的獎勵的較低份額。這為驗證人提供了優化其硬體、軟體和網路連接的激勵，以便盡可能快地處理使用者交易。

但是，如果驗證人在提交之前未能對塊進行簽名，則其簽名可能包含在下一個區塊之一中，然後包含在部分獎勵中（指數級遞減，具體取決於自生成以來已生成的塊數，例如，如果驗證人延遲了k區塊，那麼就是0.9k ）則仍將給予該驗證人。

#### 2.6.21	“深度（Depth）”。
通常，當驗證人對區塊進行簽名時，簽名僅證明區塊的相對有效性：如果該區塊和其他分片鏈中所有的先前區塊都有效，則該區塊有效。 驗證人不能因為將先前區塊中提交的無效資料視為理所當然而受到懲罰。

但是，區塊的驗人者簽名具有稱為 “深度” 的整數參數。 如果它不為零，則意味著驗證人也斷言指定數量的先前區塊的（相對）有效性。 這是 “慢” 或 “暫時離線（temporarily offline）”的驗證人捕獲並簽署一些未經簽名提交的區塊的方法。 他們仍然會獲得一些獎勵（參見 2.6.20
）。

#### 2.6.22	驗證人負責簽名的分片鏈區塊的相對有效性；絕對有效性如下。
我們想再次強調，在分片鏈區塊 B 上的驗證人簽名僅證明該區塊的相對有效性（或者如果簽名具有 “Depth”d，則可能也是 d 先前塊的相對有效性，參見 2.6.21；但這並不會影響以下的討論。換句話說，驗證人斷言通過應用 2.2.6 中描述的塊評估函數 ev_block 從先前狀態 s 獲得分片鏈的下一狀態 ：

s’ = ev_block(B)(s) (24)

以這種方式，如果原始狀態 s 證明為 “錯誤（incorrect）”（例如，由於先前區塊中有一個無效），則不能懲罰簽名塊區 B 的驗證人。漁夫（參見 2.6.4）只有在發現相對無效的區塊時才應該投訴。 PoS 系統作為一個整體努力使每個區塊相對有效，而不是遞迴（或絕對）有效。但是請注意，如果區塊鏈中的所有區塊都相對有效，那麼所有區塊和整個區塊鏈都是絕對有效的；使用區塊鏈長度的數學歸納可以很容易地顯示這個陳述。通過這種方式，對於區塊相對有效性的斷言驗證共同證明了整個區塊鏈的絕對有效性。
 
注意，通過對區塊 B 進行簽名，驗證人在給定原始狀態 s 的情況下斷言該區塊是有效的（即
，（24）的結果不是指示不能計算下一狀態的值⊥）。以這種方式，驗證人必須對在（24） 的評估期間訪問的原始狀態細胞執行最小的正式檢查。

例如，假設預期包含從提交到區塊中交易訪問帳戶的原始餘額的cell原來具有零個原始位元組， 而不是預期的 8 或 16。 然後原始餘額根本無法從cell取回，並在嘗試處理區塊時發生 “未處理的異常（unhandled exception）”。在這種情況下，驗證人不應該在遭受到懲罰時簽署這樣的區塊。

#### 2.6.23	簽名主鏈的區塊。
主鏈區塊的情況有所不同：通過簽署主鏈區塊，驗證人不僅斷言其相對有效性，還斷言所有先前區塊的相對有效性，直到該驗證人承擔其責任時的第一個區塊（但不再向後）。

#### 2.6.24	驗證人的總量。
在目前為止所描述的系統中，要選擇的驗證人總數的上限 T（參見 2.6.7）不能超過，比如幾百或一千，因為所有驗證人都應該參與 BFT 共識協議用於創建每個新的主鏈區塊，並且不清楚這些協議是否可以擴展到數千個參與者。更重要的是，主鏈區塊必須（通過質押）收集所有驗證人中至少三分之二的簽名，並且這些簽名必須包含在新區塊中（否則，系統中的所有其他節點都沒有理由在自己沒有驗證新區塊時信任它。如果超過，例如，每個主鏈區塊中必須包含1000個驗證人簽名，這將意味著每個主鏈區塊中的更多資料，由所有完整節點存儲並通過網路傳播，並且花費更多的處理能力來檢查這些簽名（在 PoS 系統中，完整節點不需要自己驗證區塊，但是它們需要檢查驗證人的簽名）。

雖然限制 T 到1000個驗證人似乎對 TON 區塊鏈的部署的第一階段來說已經足夠，但是當分片鏈總數變得大到幾百個驗證人不足以處理時，必須為未來的增長做出規定。他們都是。為此
，我們引入了一個額外的可配置參數 T'≤T（最初等於 T），並且只有頂部 T' 選舉的驗證人
（通過質押）才能創建和簽署新的主鏈區塊。

#### 2.6.25	去中心化的系統。
人們可能懷疑 TON區塊鏈證明系統依賴於 T≈1000 驗證人來創建所有分片鏈和主鏈區塊，與傳統的工作量證明區塊鏈相比，必然會變得 “過於中心化”。比如比特幣或乙太坊，每個人（原則上）都可以挖掘一個新區塊，而沒有明確的礦工總數上限。

然而，POW 如比特幣和乙太坊，目前需要大量的算力[高 “雜湊率（hash rates）”]來挖掘新區塊，並且概率很低。因此，出塊往往集中某幾個人手中，他們投入大量資金建立研發中心，這些研發中心充滿了針對挖礦優化的定制設計硬體；算力掌握在幾個大型採礦池的手中，這些採礦池集中並協調那些無法自己提供足夠 “算力” 的人而接入網路。

因此，截至 2017 年，超過 75％的新的乙太坊或比特幣區塊由不到 10 名礦工生產。事實上， 兩個最大的 乙太坊 礦池共同產生了超過一半的新區塊！顯然，這樣的系統比依賴於 T≈1000 個節點來生成新區塊的系統更加中心化。

人們可能還會注意到成為 TON區塊鏈驗證人所需的投資——即購買硬體（例如，幾個高性能伺服器）和質押資產（如果需要，可以通過一系列提名人輕鬆收集；參照 2.6.3）——比成為一個成功的比特幣或乙太坊個人礦工所需的付出低得多。實際上，2.6.7 的參數 L 將迫使提名
 
人不加入最大的 “礦池”（即，已經積累了最大質押資產的驗證人），而是尋找目前接受來自提名人資金的較小驗證人，或者甚至創建新的驗證人，因為這將允許驗證人更高比例的 s'i / si——並且還可以使用提名人的質押資產，因此從挖礦中獲得更大的獎勵。通過這種方式， TON 的 POS 實際上鼓勵分散（創建和使用更多驗證人）並懲罰中心化。

#### 2.6.26	區塊的相對可靠性。
區塊的（相對）可靠性取決於已對該區塊簽名的所有驗證人的總質押資產。換句話說，如果這個區塊被證明無效，這那某些參與者就會失去部分質押資產。如果關注轉移價值低於區塊可靠性的交易，可以認為它們足夠安全。從這個意義上講，相對可靠性是外部觀察者在特定區塊中可以擁有的信任度量。

請注意，我們說的是區塊的相對可靠性，因為它保證區塊是有效的，前提是區塊和所有其它所指的分片鏈區塊都有效（參見 2.6.22）。

區塊的相對可靠性在提交後可以增長——例如，當添加了遲來的驗證人簽名時（參見 2.6.21
）。另一方面，如果這些驗證人中的一個由於其與其他區塊有關的不當行為而失去部分或全部
質押資產，則區塊的相對可靠性會降低。

#### 2.6.27	“強化（Strengthening）” 區塊鏈
為驗證人提供激勵很重要，它可以盡可能地提高區塊的相對可靠性。 實現此目的的一種方法是向驗證人分配一小筆獎勵，以便將簽名添加到其他分片鏈的區塊中。 即使是 “將來可能（ would-be）” 的有效者，他們已經存入的質押資產不足以通過質押進入最高的 T 驗證人並被納入全域驗證人（參見 2.6.7），也可能參加這項活動（如果他們同意保留他們的質押資產而不是在失去選舉後退出它。 這些潛在的驗證人可能同時成為漁夫（參見 2.6.4）：如果他們不得不檢查某些區塊的有效性，他們也可以選擇報告無效區塊並收集相關的獎勵。

#### 2.6.28	區塊的遞迴可靠性。
還可以將區塊的遞迴可靠性定義為其相對可靠性的最小值以及它所引用的所有區塊的遞迴可靠性（例如主鏈區塊、先前的分片區鏈和相鄰的分片鏈的一些區塊）。換句話說，如果該區塊被證明是無效的，或者因為它本身無效或者因為它所依賴的區塊之一是無效的，那麼至少這個數量的錢將被某人丟失。如果真的不確定是否信任區塊中的特定交易，則應該計算該區塊的遞迴可靠性，而不僅僅是相對區塊的遞迴可靠性。

在計算遞迴可靠性時走得太遠是沒有意義的，因為如果我們看得太遠，我們將看到由驗證人簽名的塊，其質押資產已經解凍並撤回。在任何情況下，我們都不允許驗證人自動重新考慮那些舊的區塊（即如果使用了當前的可配置參數值，則在兩個月前創建），並創建從它們開始的分叉或使用輔助設備糾正它們 “垂直區塊鏈（vertical blockchains）”（參見 2.1.17），即使它們結果無效。我們假設兩個月的時間段為檢測和報告任何無效區塊提供了充足的機會，因此如果在此期間沒有對區塊進行質詢，則根本不可能受到質疑。

#### 2.6.29	POS 的結果。
TON區塊鏈使用的權益證明方法的一個重要結果是，TON 區塊鏈的輕節點（運行輕節點的用戶端）不需要下載所有分片鏈甚至主鏈區塊的 “頭（headers）”，以便能夠自行檢查由完整節點提供給它的 Merkle 證明的有效性作為其查詢的答案。
 
實際上，因為最新的分片鏈區塊雜湊包含在主鏈區塊中，所以完整節點可以很輕鬆地提供Merkle 證明，即給定的分片鏈區塊從主鏈區塊的已知雜湊開始有效。接下來，工作中的節點只需要知道主鏈的第一個區塊（其中第一組驗證人被公佈），其中（或至少其中的雜湊）可以內置到用戶端軟體中，並且僅大約每個月發生一個主鏈區塊，其中宣佈新選出的驗證人集，因為該塊將由前一組驗證人簽名。從那開始，它可以獲得幾個最新的主鏈區塊，或者至少它們的區塊頭和驗證人簽名，並使用它們作為檢查由完整節點提供的 Merkle 證明的基礎。

### 2.7	拆分和合併分片鏈
TON區塊鏈最具特色、最獨特的功能之一是一個分片能在負載變高時自動將分為兩個，並在負載下降時合二為一（參見 2.1.10）。由於其獨特性和對整個項目擴容的重要性，我們須對此進行詳細討論。

#### 2.7.1 分片配置

想一下，在任何給定的時刻，每條工作鏈會被分成一條或幾條分片鏈（w，s）（參見 2.1.8
）。這些分片鏈可用一個根節點為（w，∅）的二叉樹的許多葉子來表示，每個非葉子節點（w
，s）都有子節點（w，s.0）和（w，s.1）。通過這種方式，屬於工作鏈 w 的每個帳戶都被具體分配到一個分片，並且知道當前分片鏈配置的人都可以確定包含帳戶 account_id 的分片（ w，s）：它是唯一一個用二進位字元串 s 作為account_id首碼的分片。
分片配置——即此分片二叉樹，或給定 w 的所有活躍節點（w，s）的集合（對應分片 二叉樹
23
的葉子）——是主鏈狀態的一部分，並且可用於所有追蹤主鏈的人。

#### 2.7.2 最新的分片配置和狀態

想一下，最新的分片鏈區塊的雜湊值包含在每個主鏈區塊中。這些雜湊值按分片二叉樹（實際上是樹的集合，每個工作鏈一個）排列。這樣每個主鏈區塊都包含最新的分片配置。

#### 2.7.3 宣布並執行分片配置和更改

可以通過兩種方式更改分片配置：一個分片（w,s）可以分為兩個（w,s.0）和（w,s.1），或兩個 “兄弟” 分片（w,s.0）和（w,s.1）可以合併為一個分片（w,s）。
這些拆分 / 合併操作會預先在幾個區塊上公佈（例如，26；這是可配置參數），首先在相應的分片鏈區塊的 “區塊頭” 中，然後在引用這些分片鏈區塊的主鏈區塊中。所有相關方都需要這種預先公佈，以準備計畫是式更改（例如，如 3.3 中所述，搭建覆蓋多播網路傳播新創建的分片鏈的新區塊）。之後更改得以進行，（在拆分的情況下）首先進入分片鏈區塊的（區塊頭）
（在合併的情況下，兩個分片鏈的區塊都應該進行更改），然後傳播到主鏈區塊。通過這種方式，主鏈區塊不僅定義了創建之前的最新分片配置，還定義了下一個即將分片配置。



---

23 實際上，分片配置完全由最後一個主鏈區塊決定；這樣就簡化了分片配置的流程。
 
---

#### 2.7.4 新分片鏈的驗證人任務組
想一下，每個分片（即每個分片鏈）通常配有一個驗證人子集（驗證人任務組），該子集專門用於創建和驗證相應分片鏈中新的區塊（參見 2.6.8）。這些任務組隔一段時間（大約一小
24
時）選出，並且提前一段時間（大約一小時）知曉，並且在此期間是不可更改。

但是，由於拆分 / 合併操作，實際的分片配置可能會在此期間發生更改。必須將任務組分配給新創建的分片。可通過如下操作：
請注意，任何活躍分片（w，s）都將是某些唯一確定的原始分片（w，s'）的衍生，即s' 是 s 的首碼，或者將是原始分片（w，s'）的子樹的根，其中 s 將是每個 s' 的首碼。在第一種情況下，我們只需將原始分片（w，s'）的任務組重新用作新分片（w，s）的任務組。在後一種情況下，新分片（w，s）的任務組將是所有原始分片（w，s'）的任務組的並集，這些原始分片都是分片樹中（w，s）的衍生。
通過這種方式，每個活躍分片（w，s）都有一個明確定義的驗證人子集（任務組）。拆分分片時，兩個子代繼承了原始分片整個任務組。合併兩個分片時，它們的任務組也會合並。

追蹤主鏈狀態的任何人都可以為每個活躍分片計算驗證人任務組。

#### 2.7.5	原任務組工作期間限制拆分/合併的操作

最終將考慮新的分片配置，並且將自動為每個分片分配新的專用驗證人子集（任務組）。在此之前，必須對拆分 / 合併操作施加一定的限制；否則，如果原始分片快速分成 2k 個新分片， 則原始任務組可能最終會同時驗證一個很大k值的 2k 個分片鏈。
這是通過對從原始分片配置（用於選擇當前負責的驗證人任務組的配置）中刪除活動分片配置的距離施加限制來實現的。例如，如果 s' 是 s 的前身（即s'是二進位字元串s的首碼），則可要求分片樹中從活動分片（w，s）到原始分片（w，s'）的距離不得超過 3。如果 s' 是 s 的後代（即 s 是 s' 的首碼，則距離不得超過 2。否則，不允許拆分或合併操作。
粗略地說，在給定驗證人任務組的工作期間對分片（例如，三個）或合併（例如，兩個）的次數施加限制。除此之外，在通過合併或拆分創建了一個分片之後，一段時間（一定數量的塊） 內不能重新配置。

#### 2.7.6 確定拆分操作的必要性

分片鏈的拆分操作通過某些形式條件觸發（例如，如果連續 64 個區塊，則分片鏈區塊至少滿90％）。這些條件由分片鏈任務組監視。如果滿足這些條件，首先在新的分片鏈區塊的區塊頭中包含“拆分準備”標誌（並且傳播到引用該分片鏈區塊的主鏈區塊）。然後，在幾個區塊之後，“拆分完成”標誌被包含在分片鏈區塊的區塊頭中（並傳播到下一個主鏈區塊）。




---

24 除非有些節點由於簽署無效區塊而被暫時或永久禁止，被自動剔除在專案組外。

---

#### 2.7.7 執行災分操作

在分片鏈（w，s）的區塊 B 中包含“拆分完成”標誌之後，該分片鏈中不會有後續區塊 B'。 相反，將分別創建分片鏈（w，s.0）和（w，s.1）的兩個區塊 B0′ and B1′ ，兩者都將區塊 B 引用為它們的前一個區塊（並且都將通過塊頭中的flag標記已拆分分片）。下一個主鏈區塊將包含新分片鏈的區塊 B0' 和 B1' 的雜湊值；不允許包含分片鏈（w，s）新區塊 B' 的雜湊值，因為“拆分完成”事件已經被提交到先前的主鏈區塊中。
請注意，兩個新的分片鏈將由與舊驗證人相同的驗證人任務組驗證，因此它們將自動獲得其狀態的副本。從無限分片範式（Infinite Sharding Paradigm）的角度來看，狀態拆分操作本身非常簡單（參見 2.5.2）。

#### 2.7.8 確定合併操作的必要性。

分片鏈合併操作的必要性可通過某些形式的條件檢測到（例如，對於 64 個連續區塊，兩個兄弟分片鏈區塊的大小之和不超過最大區塊大小的 60％）。這些形式條件還應考慮這些區塊所消耗的總 gas，並將其與當前區塊 gas限制進行比較，否則區塊可能會很小，因為有一些計算密集型交易會阻止更多的交易。

這些條件由兄弟分片（w，s.0）和（w，s.1）的驗證人任務組監視。請注意，兄弟分片必須是超立方體路由的相連分片（參見 2.4.19），因此來自任一分片的任務組的驗證人將在某種程度上監視兄弟分片。
當這些條件得到滿足時，任何一個驗證人子組都可以通過發送特殊消息向另一個驗證人建議它們進行合併。然後，它們組合成一個臨時的 “合併任務組”，具有組合的成員能夠運行 BFT 共識演算法，並在必要時傳播區塊更新和區塊候選。
如果它們就合併的必要性和準備情況達成共識，則 “合併準備” 標誌將被提交到每個分片鏈的某些區塊的區塊頭中，同時還有兄弟任務組至少三分之二的驗證人的簽名（並傳播到下一個主鏈區塊，以便每個人都可以為即將進行的重新配置做好準備）。但是，它們繼續為某些預定義數量的區塊創建單獨的分片鏈區塊。

#### 2.7.9

之後，當來自兩個原始任務組的驗證人準備好成為合併的分片鏈的驗證人時（這可能涉及從兄弟分片鏈轉移樁體和狀態合併操作），將提交“合併完成”標誌至它們分片鏈區塊的區塊頭中
（此事件傳播到下一個主鏈區塊），並停止在單獨的分片鏈中創建新區塊（一旦出現合併完成
標誌，則禁止在單獨的分片鏈中創建區塊）。反之，則創建一個合併的分片鏈區塊（由兩個原始任務組的並集），在其“區塊頭”中引用它的兩個 “前區塊”。這反映在下一個主鏈區塊中，它將包含合併分片鏈區塊新創建的的雜湊值。之後，合併的任務組繼續在合併的分片鏈中創建區塊。
 
### 2.8	區塊鏈專案的分類
我們將通過比較 TON區塊鏈與現有的區塊鏈專案來結束對 TON區塊鏈的討論。然而在此之前
，我們必須引入足夠普遍的區塊鏈項目分類，基於此分類的特定區塊鏈專案比較將在2.9 裡展開。

#### 2.8.1	區塊鏈專案的分類
第一步，我們先提出區塊鏈（即區塊鏈項目）的一些分類標準。這必須忽略所考慮項目的一些具體和獨特的特徵，所以任何分類都可能不完整，並且是表面的。但是我們認為這是必要的， 至少提供了區塊鏈領域項目粗略鳥瞰的第一步。
我們考慮的標準清單如下：

•	單鏈與多鏈架構（參見 2.8.2）

•	共識演算法：POS 權益證明與 POW 工作量證明（參見 2.8.3）

•	對於權益證明系統，具體的區塊生成、驗證和所使用的共識演算法（兩個演算法包括
DPOS 與 BFT；參見 2.8.4）

•	支援 “任意”（圖靈完備）智慧合約（參見 2.8.6） 多鏈系統有額外的分類標準（參見 2.8.7）：
•	所包含區塊鏈的類型和規則：同構、異構（參見 2.8.8）、混合（參見 2.8.9）。 聯
盟鏈（參見 2.8.10）。

•	缺少或存在內部或外部的主鏈（參見 2.8.11）

•	系統支援分片（參見 2.8.12）。 靜態或動態分片（參見 2.8.13）。

•	所包含區塊鏈之間的相互作用：鬆散耦合和緊密耦合系統（參見 2.8.14）

#### 2.8.2	單鏈和多鏈項目
第一個分類標準是系統中區塊鏈的數量。最老也是最簡單的項目只包含一條鏈（簡稱  “單鏈項
目”）；更複雜的專案使用（或者更確切地說，計畫使用）多個區塊鏈（“多鏈項目”）。

單鏈項目通常更簡單，測試更好；它們經受住了時間的考驗。它們的主要缺點是性能低，或者
25
交易輸送量最低，每秒 10 筆（比特幣）到 140 筆 （乙太坊）不等。一些專門的系統（如比
特股）每秒能夠處理成千上萬的交易，代價是要求區塊鏈狀態適合記憶體，並將處理限制在預定
義的交易中，然後由高度優化的代碼執行，這些代碼用 C ++ 這樣的語言編寫（沒有 VM）。




25同15類似，當前情況。現已有更新計畫，將乙太坊的交易輸送量提高至幾倍以上。
 
多鏈項目保證了大家都想要的可擴展性，可以提供更大的總狀態和更高的tps，代價是使項目更加複雜，並且其實現起來更具挑戰性。因此，目前幾乎沒有太多的多鏈專案在運行，但大多數提出的專案都是多鏈專案。我們相信未來屬於多鏈項目。

#### 2.8.3	創建和驗證區塊：工作量證明與權益證明
另一個重要的區別是演算法和協定，用於創建和傳播新區塊，檢查有效性，如果需要分叉則選擇一種分叉。

兩種最常見的範例是工作量證明（PoW）和權益證明（PoS）。工作量證明方法通常允許任何節點創建（“挖”）新區塊（並獲得與挖礦相關的一些獎勵），如果它很幸運地在其它競爭者前解決反之就無用的計算問題（通常涉及大量的雜湊值計算）。在分叉的情況下（例如，如果兩個節點在前一個區塊後發佈兩個都可能有效但不同的區塊），則最長的分叉獲勝。通過這種方式，保證區塊鏈的不可更改性的是基於生成區塊鏈所花費的工作量（算力資源）：任何想要創建區塊鏈分叉的人都需要重新做這項工作來創建替代方案已提交區塊的版本。為此，它需要控制創建新區塊所花費的總算力的 50％以上，不然另外一條分叉成為最長鏈的成功率指數型下降。

權益證明方法基於一些特殊節點（驗證人）做出的大量質押（stake，加密貨幣中的概念）來聲明它們已經檢查（驗證）了一些區塊並且發現它們是正確的。驗證人簽名區塊，並為此獲得一些小獎勵；但是，如果一個驗證人被抓到簽了一個不正確的區塊，並且有證據表明，那麼其部分或全部質押資產將被沒收。由此，驗證人對區塊鏈有效性的總 質押資產量確保了區塊鏈的有效性和不可更改性。

利用權益證明方法更加自然，它激勵驗證人（取代 PoW 礦工）執行有用的計算（需要檢查或創建新的區塊，尤其是通過執行區塊列出的所有交易進行檢查或創建）而不是計算可能無用的雜湊。通過這種方式，驗證人將購買更適合於處理使用者交易的硬體，以便領取與這些交易相關的獎勵，從整個系統的角度來看，這似乎是非常有用的投資。
然而，權益證明制度在實施方面更具挑戰性，因為需要許多罕見但可能的條件。例如，一些惡意驗證人可能合謀破壞系統以獲取一些利潤（如，改變它們自己的加密貨幣餘額）。這導致了一些不同尋常的遊戲理論問題。
簡而言之，權益證明更符合自然規律，更有前途，特別是對於多鏈項目而言（因為如果有許多區塊鏈，工作量證明需要大量的計算資源），但必須更仔細計畫和實施。大多數目前正在運行的區塊鏈項目，尤其是最老的項目（比如比特幣和最初的乙太坊），都使用了工作量證明。

#### 2.8.4	POS 的演變：DPOS vs BFT
雖然工作量證明演算法彼此非常相似，並且主要區別在於必須為挖掘新區塊而計算的雜湊函數， 但是權益證明演算法有更多可能性。很值得對權益證明進行細分。
這裡必須要回答下關于權益證明演算法的問題：

•	誰可以生成（“挖”）新區塊——任何全節點，或只是生成（相對）小驗證人子集的成員？ （大多數 PoS 系統需要新生成的區塊，並由一名指定驗證人簽名。）
 
•	驗證人是否通過其簽名保證區塊的有效性，或者是否所有全節點都可以自行驗證所有區塊？（可擴展的 PoS 系統必須依賴驗證人簽名，而不是要求所有節點驗證所有區塊鏈的全部區塊。）
•	是否有下一個區塊鏈區塊的（提前知曉的）指定出塊人，以便其他人無法生產該區
塊？

•	新創建的區塊最初僅由一個驗證人（其出塊人）簽署的，還是必須從一開始就收集大多數驗證人簽名？
雖然根據這些問題的答案，似乎有 24 種可能的 PoS 演算法類別，但實際區別歸結為兩種主要的PoS 方法。 實際上，用於可擴展多鏈系統的大多數現代 PoS 演算法以相同的方式回答前兩個問題：只有驗證人才能生成新區塊，並且它們保證區塊有效性，而不需要所有全節點檢查所有區塊的有效性。
至於最後兩個問題，它們的答案非常相關，基本上只留下兩個基本選項：

•	委託權益證明（DPOS）：每個區塊都有一個眾所周知的指定出塊人；除此之外沒有人可以出塊；新區塊最初只由其出塊的驗證人簽名。
•	拜占庭容錯（BFT）PoS 演算法：有一個已知的驗證人子集，其中任何一個都可以提出一個新區塊；幾個建議候選人中的下一個實際區塊（在公佈到其他節點之前必須由大多數驗證人驗證和簽名）的選擇是通過拜占庭容錯共識協議來實現的。

 
#### 2.8.5	DPOS
 
BFT POS 的比較
 

BFT 方法的優點在於，新產生的區塊從一開始就具有大多數驗證人的簽名，證明其有效性。另一個優點是，如果大多數驗證人正確執行 BFT 共識協議，則根本不會出現任何分叉。另一方面，BFT 共識演算法往往相當複雜，需要更多時間讓驗證人子集達成共識。因此不能經常生成區塊。這就是為什麼我們期望 TON 區塊鏈（從這個分類的角度來看是一個 BFT 項目）每5 秒只產生一次區塊。在實踐中，如果驗證人遍佈全球，這個間隔可能會減少到 2-3 秒（但我們不承諾這一點），但不會減少更多。
DPOS 演算法的優點非常簡單直接。它可以經常生成新的區塊——比如每兩秒1個區塊，或者甚至每秒1個區塊26，因為它依賴於事先已知的指定區塊生產者。
但是，DPOS 要求所有節點——或至少所有驗證人——驗證收到的所有區塊，因為生成和簽署新區塊的驗證人不僅確認該區塊的相對有效性，而且還確認它所引用的前一區塊的有效性， 以及之後回到鏈上的所有區塊（可能直到當前驗證人子集的工作期開始）。當前驗證人子集上存在預定順序，因此對於每個區塊，都有指定的出塊人（即期望生成該塊的驗證人）；這些指定的出塊人以迴圈方式進行輪流。通過這種方式，區塊首先僅由其出塊的驗證人簽名；然後， 挖下一個區塊挖時，它的出塊人選擇引用這個區塊而非其之前一個區塊（否則它的區塊將位於較短的鏈中，可能導致輸掉 “最長分叉” 競爭），下一個區塊的簽名本質上也是前一區塊的附加簽名。通過這種方式，新區塊逐漸收集更多驗證人的簽名——例如，在生成接下來20個區


---

26 有的人甚至提出DPOS半秒的區塊產生時間，即使驗證人遍佈各大洲也不太實際。

---

塊所需的時間內收集 20 個簽名。一個全節點要麼需要等待這20個簽名，要麼自己驗證區塊， 從一個充分確認區塊（比如回退20個區塊）開始，這可能不是那麼容易。
DPOS 演算法明顯的缺點是，只有在挖了 20 多個區塊之後，新區塊（以及提交到新區塊的交易）才能達到與BFT相同的信任級別（2.6.28 中討論的“遞迴可靠性”）。 與之相對的BFT 演算法，可立即提供此級別的信任（例如，20 個簽名）。另一個缺點是 DPOS 使用“最長分叉勝利”方法切換到其他分叉；如果至少一些出塊人未能在我們感興趣的區塊之後生成後續的區塊
（或者由於網路磁碟分割或複雜的攻擊，我們未能觀察到這些區塊），這很可能導致分叉。

我們認為 BFT 方法雖然比 DPOS 實現更複雜，區塊之間需要更長的時間間隔，但更適合於
“緊密耦合”（參見 2.8.14）多鏈系統，因為其他區塊鏈在新區塊中看到已提交的交易之後可立即行動（例如，為交易生成一條消息），而不用等待 20 次有效性確認（即，接下來的 20 個區塊），或等待接下來的6個區塊以確保沒有分叉出現並自行驗證新區塊（在可擴展的多鏈系統中驗證其他區塊鏈的區塊可能無法實現）。因此，它們可以實現可擴展性，同時保持高可靠性和可用性（參見 2.8.12）。
另一方面，DPOS 可能是 “鬆散耦合” 多鏈系統的理想選擇，其中不需要區塊鏈之間的快速交互——例如，如果每個區塊鏈（“工作鏈”）代表一個單獨的分散式交換，區塊鏈間的交互僅限於將代幣從一個工作鏈轉移到另一個工作鏈中（或者更確切地說，以一個接近 1:1 的速率將一個山寨幣交易到另一個工作鏈中）。這是比特股項目實際在做的，它非常成功地使用了 DPOS。

總而言之，雖然 DPOS 可以生成新的區塊並且更快地包含交易（區塊之間的間隔更小），但這些交易達到的信任級別（其他區塊鏈和鏈下應用所“提交”和“不可更改”的級別） 速度比 BFT 系統慢得多——比如說，30 秒27而不是 5 秒。更快的交易包含並不意味著更快的交易提交。如果需要快速的區塊鏈間交互，這可能會成為一個巨大的問題。在這種情況下，必須放棄DPOS ，選擇 BFT PoS。

#### 2.8.6	支援交易裡的圖靈完備代碼，即允許執行任意智能合約
區塊鏈項目通常會在其區塊中收集一些交易，這會以一種被認為有用的方式改變區塊鏈狀態
（例如，將一定量加密貨幣從一個帳戶轉移到另一個帳戶）。一些區塊鏈項目可能只允許某些特定的預定義分片的事務（例如，在簽名正確的情況下，從一個帳戶到另一帳戶的價值轉
移）。其他人可能會在交易中支援某種有限形式的腳本。最後，一些區塊鏈支援在交易中執行任意複雜的代碼，使系統（至少在原理上）能夠支援任意應用程式，只要系統的性能允許。這通常與 “圖靈完備的虛擬機器和指令碼語言”（意味著任何可以用其他計算語言編寫的程式可以重寫以在區塊鏈內執行）和 “智慧合約”（區塊鏈中的程式）有關。
當然，對任意智慧合約的支援使系統真正具有靈活性。另一方面，這種靈活性需要付出代價： 這些智慧合約的代碼必須在某個虛擬機器上執行，並且當有人想要創建或驗證區塊時，必須每次為每個交易執行此操作。與預定義且不可更改的簡單交易類型相比，這會降低系統的性能，而簡單的交易類型可以通過使用諸如 C ++（而不是某些虛擬機器）之類的語言實現它們的處理來優化。

---

27 例如，至今為止最優秀的一個DPOS項目，EOS承諾45秒的確認和區塊鏈間交互延遲的時間（參照[5]，“交易確認”和“鏈間交互延遲”）。

---

最終，對圖靈完備智慧合約的支持似乎在任何通用區塊鏈專案中都是可取的；否則，區塊鏈專案的設計者必須事先決定他們的區塊鏈將用於哪些應用程式。事實上，正是比特幣不支援智慧合約才有了乙太坊等新的專案。
在（異構；參見 2.8.8）多鏈系統中，一些區塊鏈（即工作鏈）中支援圖靈完備智慧合約，另一些支持預定義高度優化過的交易，這樣可保持 “兩全其美”。

#### 2.8.7	多鏈系統的分類
到目前為止，該分類對於單鏈和多鏈系統都是有效的。然而，多鏈系統承認了更多的分類標準
，反映了系統中不同區塊鏈之間的關係。我們現在來討論這些標準。

#### 2.8.8	區塊鏈類型：同構與異構系統
在多鏈系統中，所有區塊鏈基本上是相同類型並且具有相同的規則（即，使用相同格式的交易
，用於執行智慧合約代碼的相同虛擬機器，共用相同的密碼保存等等），這種相似性被明確使用
，但每個區塊鏈中的資料不同。在這種情況下，我們將這一系統稱為同構的。否則，不同的區塊鏈（這種情況通常稱為工作鏈）可以有不同的“規則”。那麼，我們就將這一系統稱為異構 的。

#### 2.8.9	同構-異構混合系統
有時我們有一個混合系統，其中的區塊鏈有幾組類型或規則，但是存在許多具有相同規則的區塊鏈，並且這是公認的事實。然後它是一個同構-異構混合系統。據我們所知，TON 區塊是這類系統僅有的一個例子。

#### 2.8.10	若干工作鏈的異構系統具有相同的規則，聯盟鏈
一些情況下，具有相同規則的若干區塊鏈（工作鏈）可以存在於異構系統中，但是它們之間的交互與具有不同規則的區塊鏈之間的相互作用相同（即，它們的相似性未被明確使用）。即使它們似乎使用“同樣的”加密貨幣，它們實際上使用不同的“山寨幣”（加密貨幣的不同化身）。有時人們甚至可以使用某些機制將這些山寨幣按近1：1 的比例兌換。然而，在我們看來這並不能使系統同構化；它仍然是異構的。我們將這種具有相同規則的異構工作鏈集合稱為聯盟 鏈。
雖然允許用相同規則創建多個工作鏈的異構系統（即聯盟鏈）看起來似乎是構建可擴展系統的廉價方式，但這種方法也有許多缺點。從本質上講，如果有人在許多具有相同規則的工作鏈中運行大型項目，這（實際上）並非大型項目，而是該專案的許多小實例。這就像一個聊天應用程式（或遊戲），在任一聊天（或遊戲）房間中最多只允許 50 個成員，但通過創建新房間來“擴容”，以在必要時容納更多用戶。由此，很多用戶可以參與聊天或遊戲，但我們可以說這樣的系統真正可擴展嗎？

#### 2.8.11	內部或外部存在主鏈
有時，多鏈專案有一個獨特的 “主鏈”（有時稱為 “控制區塊鏈”），例如可用於存儲系統的整體配置（所有活躍區塊鏈的集合，或者更確切地說是工作鏈 ）、當前的驗證人集（POS系統）
 
等等。有時其他區塊鏈與主鏈“綁定”，例如通過將最新區塊的雜湊值存入其中（TON區塊鏈也是如此）。

在某些情況下，主鏈是外部的，這意味著它不是該項目的一部分，而是一些其它預先存在的區塊鏈，最初與新專案的使用完全無關，並且對其不可知。例如，我們可以嘗試使用乙太坊區塊鏈作為外部項目的主鏈，並為此（比如挑出和懲罰驗證人）將特殊智慧合約發佈至乙太坊區塊鏈。

#### 2.8.12	分片支援

一些區塊鏈專案（或系統）本身支援分片，這意味著幾個（必然是同構的；參見 2.8.8）區塊鏈被認為是單個（從高級別的角度來看）虛擬區塊鏈的分片。例如，可以創建具有相同規則的256 個分片鏈，並根據其 account_id 的第一個位元組將帳戶的狀態保持在一個選定的分片中。
分片是擴展區塊鏈系統的一種自然方法，因為如果它被正確實現，系統中的使用者和智慧合約根本不需要知道分片鏈的存在。實際上，當負載變得過高時，人們通常希望為現有的單鏈專案
（例如乙太坊）增加分片。

另一種擴展方法是使用 2.8.10 中描述的異構工作鏈的“聯盟鏈”，允許每個用戶將她的帳戶保存在她選擇的一個或多個工作鏈中，並在必要時將資金從她一條工作鏈的帳戶轉移到另一個工作鏈中，基本上執行 1：1 的山寨幣交換操作。這種方法的缺點已在 2.8.10 中討論過。
然而，分片要快速可靠地實現並不容易，因為它意味著不同分片鏈之間的大量消息。例如，如果帳戶在 N 個分片之間均勻分配，並且交易只是從一個帳戶到另一個帳戶的簡單資金轉帳， 那麼在單鏈中只會執行所有交易的一小部分（1 / N）；幾乎所有（1——1 / N）交易都涉及兩個區塊鏈，需要區塊鏈間通信。如果我們希望這些交易快速進行，我們需要用一個快速系統在分片鏈之間傳輸消息。換句話說，區塊鏈專案需要在 2.8.14 中描述的意義上 “緊密耦合”。

#### 2.8.13	動態和靜態分片

分片可能是動態的（如果在必要時自動創建其他分片）或靜態的（如有預定義數量的分片，只能通過硬分叉來修改）。大多數分片提案都是靜態的。TON區塊鏈使用動態分片（參見 2.7
）。

#### 2.8.14	區塊鏈之間的相互作用：鬆散耦合系統和緊密耦合系統
可以根據組成區塊鏈之間支持的交互級別對多鏈項目進行分類。

最低水準的支持是不同區塊鏈之間沒有任何交互作用。我們在這裡不考慮這種情況，因為我們寧願說這些區塊鏈不是一個區塊鏈系統的一部分，而只是相同區塊鏈協定的單獨實例。
下一級支援是對區塊鏈之間的消息傳遞沒有任何具體支援，原則上使交互成為可能，但很難 用。我們稱這種系統為 “鬆散耦合”；我們必須發送消息並在區塊鏈之間傳遞價值，好像它們是屬於完全獨立的區塊鏈項目的區塊鏈一樣（例如，比特幣和乙太坊；想像兩方想要將比特幣區塊鏈中的一些BTC轉為乙太坊區塊鏈中的ETH）。換句話說，我們必須在源區塊鏈的區塊中包含出站消息（或其生成交易）。然後，她（或其他一方）必須等待足夠的確認（例如給定數量
 
的後續區塊）以將原始交易視為“已提交”和“不可變更”，以便執行外部操作。只有這樣，才能提交將消息中繼到目標區塊鏈的交易（可能連同原始交易的引用和Merkle存在證明）。
如果在傳輸消息之前沒有等待足夠長的時間，或者由於其他原因發生了分叉，則兩個區塊鏈的連接狀態變得不一致：消息被傳遞到第一個區塊鏈（最終選擇的分叉）中從未生成過的第二個區塊鏈中。
有時添加對消息傳遞的部分支援，方式是通過標準化消息格式以及所有工作鏈區塊中輸入和輸出訊息佇列的定位（這在異構系統中尤其有用）。雖然這在一定程度上促進了消息傳遞，但它在概念上與先前的情況沒有太大的不同，因此這種系統仍然 “鬆散耦合”。
相比之下，“緊密耦合” 系統包括在所有區塊鏈之間提供快速消息傳遞的特殊機制。所期望的行
為是能夠在原始區塊鏈的區塊中生成消息之後立即將消息傳遞到另一個工作鏈。另一方面，
“緊密耦合”系統也可望在分叉的情況下保持整體一致性。雖然這兩個要求乍一看似乎是矛盾的
，但我們認為 TON 區塊鏈使用的機制（將分片鏈區塊雜湊包含在主鏈區塊中；使用“垂直”區塊鏈來修復無效區塊，參見 2.1.17 ；超立方路由，參見 2.4.19；即時超立方體路由，參見2.4.20）能使其成為“緊密耦合”系統，也許是目前唯一一個例子。
當然，構建“鬆散耦合”系統要簡單得多；然而，快速有效的分片（參見 2.8.12）要求系統 “緊
密耦合”。

#### 2.8.15	簡化分類，幾代區塊鏈專案
到目前為止，我們提出的分類將所有區塊鏈項目拆分為許多類。但是我們使用的分類標準在實踐中恰好相關。這使我們能夠對區塊鏈專案分類提出簡化的“按代際分類”的方法，通過一些例子粗略反映現實。尚未實施和部署的專案以斜體顯示；一代區塊鏈專案中最重要的特徵用粗體顯示。
•	第一代：單鏈，PoW，不支持智慧合約。示例：比特幣（2009）和許多其他無趣的模仿者（萊特幣、門羅幣……）。
•	第二代：單鏈，PoW，支持智慧合約。示例：乙太坊（2013 年；2015 年部署）， 原始形式。

•	第三代：單鏈，PoS，支持智慧合約。示例：未來的乙太坊（2018 年或更晚）。

•	其他第三（3'）代：多鏈，PoS，不支持智慧合約，鬆散耦合。示例：比特股 （
2013-2014；使用 DPOS）。

•	第四代：多鏈，PoS，智慧合約支持，鬆散耦合。 示例：EOS（2017年；使用
DPOS），波卡（2016年；使用 BFT）。

•	第五代：多鏈，PoS 與 BFT，智慧合約支持，緊密耦合，分片。 示例：TON（
2017年）。

雖然並非所有區塊鏈項目都能歸屬於這些類別中的一個，但大多數都屬於這些類別。
 
#### 2.8.16	改變區塊鏈項目 “基因（genome）” 的複雜性
上述分類定義了區塊鏈專案的 “genome（基因）”。這個基因組非常“僵硬（rigid）”：一旦項目部署並且被很多人使用，就幾乎不可能改變它。一種選擇是需要一系列硬分叉（這需要社區多數人的批准），即使這樣，為了保持以後相容，改變也需要非常保守（例如，改變虛擬機器的語義可能打破現有的智慧合約）。另一種選擇是創建具有不同規則的新的 “側鏈”，並以某種方式將它們綁定到原始項目的一個區塊鏈（或多個區塊鏈）。有人可能會使用現有單鏈專案的區
塊鏈作為外部主鏈，作為一個基本上是新的獨立項	28
目。

我們的結論是項目的 “基因”一旦部署就很難改變。即使從 PoW 開始並計畫在未來用 PoS 替
 
換也是相當複雜	29
 
設計的專案沒有分片而後再加入，這
 
30實
 
際上，將智慧合約的支持添加到老專案（即比特幣）中被認為是不可能的（或者說至少是大多數比特幣社區不歡迎的），並最終導致創建一個新的區塊鏈專案——乙太坊。

#### 2.8.17	TON 區塊鏈的 “基因（genome）”
因此，如果想要構建可擴展的區塊鏈系統，必須從一開始就仔細選擇其基因。如果系統要支援將來在部署時未知的某些其他特定功能，那麼它應該從一開始就支援“異構”工作鏈（具有可能不同的規則）。 為了使系統真正可擴展，它必須從一開始就支持分片；只有當系統 “緊密耦合” 時（參見 2.8.14），分片才有意義，這反過來意味著存在主鏈、快速的區塊鏈間消息系、BFT PoS 的使用等等。

| 項目      | 年份        | G. | 共識    | Sm. | Ch. | R.  | Sh.  | Int. |
|-----------|-------------|----|---------|-----|-----|-----|------|------|
| Bitcoin   | 2009        | 1  | PoW     | 否  | 1   |     |      |      |
| Ethereum  | 2003，2005  | 2  |   PoW   | 是  | 1   |     |      |      |
| NXT       | 2014        | 2+ | PoS     | 是  | 1   |     |      |      |
| Tezos     | 2017,？     | 2+ | PoS     | 是  | 1   |     |      |      |
| Casper    | 2015,(2017) | 3  | PoW/Pos | 是  | 1   |     |      |      |
| BitShares | 2013,2014   | 3’ | DPos    | 否  | m   | ht. | 否   | L    |
| EOS       | 2016,(2018) | 4  | DPos    | 是  | m   | ht. | 否   | L    |
| Polkadot  | 2016,(2019) | 4  | PoS BFT | 是  | m   | ht. | 否   | L    |
| Cosmos    | 2017, ?     | 4  | PoS BFT | 是  | m   | ht. | 否   | L    |
| TON       | 2017,(2018) | 5  | PoS BFT | 是  | m   | mx  | dyn. | T    |
表1：一些著名區塊鏈鏈項目概要。這些列是：項目——項目名稱；年份——公告年份和部署年份； g .-代際（見2.8.15）；共識——公式演算法（見2.8.3和2.8.4）； Sm.–支持任意代碼
（智能合約；見2.8.6）； Ch.——單/多鏈系統（見2.8.2）；R .——異質/同質多鏈系統（見2.8.8）；SH.——支持分片（見2. 8。12）； Int.-區塊鏈之間的交互，[L(oose)]——鬆散，或[T(ight)]——緊密（見2.8.14）。

---

28 例如，Plasma專案計畫使用乙太坊區塊鏈作為其（外部）主鏈；它與乙太坊並沒有太多交互， 並且所提出和實施的團隊與乙太坊專案毫無關係。
29 截至2017年，乙太坊依舊在努力從PoW向PoW+PoS系統轉變；我們希望它未來能真正實現PoS
。
30 2015年，乙太坊有提出過幾個分片方案；在不破壞乙太坊或者創建一個基本上獨立的平行專案的情況下，如何實施並部署依舊未知。

---

當考慮到所有這些影響時，TON 區塊鏈項目做出的大多數設計選擇看起來都很自然，並且幾乎是唯一可能的選擇。

### 2.9	與其他區塊鏈項目的比較
我們通過嘗試在包含現有和建議的區塊鏈項目的地圖上找到它TON Blockchain的位置來結束我們對 TON Blockchain 及其最重要和獨特特徵的討論。我們使用 2.8 中描述的分類標準，以統一的方式討論不同的區塊鏈專案，並構建這樣的“區塊鏈項目圖”。 我們將此地圖表示為表 1
，然後分別簡要討論幾個項目，指出它們可能不適合一般方案的特性。

#### 2.9.1	比特幣（Bitcoin）[12]；https://bitcoin.org/。
比特幣（2009年）是第一個也是最著名的區塊鏈項目。這是一個典型的第一代區塊鏈項目： 單鏈，使用PoW和“最長分叉勝利”的分叉選擇演算法，它沒有圖靈完備指令碼語言（但是，支持沒有迴圈的簡單腳本）。比特幣區塊鏈沒有帳戶的概念；它使用 UTXO（Unspent Transaction Output）模型。

#### 2.9.2	乙太坊（Ethereum）[2] ；https://ethereum.org/。

乙太坊（2015年）是第一個支持圖靈完備智慧合約的區塊鏈。因此，它是典型的第二代項目
，也是其中最受歡迎的專案。它使用了工作量證明，但有智慧合約和帳戶。

#### 2.9.3	未來幣（NXT）； https://nxtplatform.org/。
NXT（2014）是第一個基於 PoS 的區塊鏈和貨幣。它仍然是單鏈，沒有支持智慧合約。

#### 2.9.4	Tezos；https://www.tezos.com/。

Tezos（2018 年或更晚）是一個基於 PoS 的單鏈項目。我們在這裡提到它，是因為它的獨特功能：它的區塊解釋函數 ev_block（參見 2.2.6）不是固定的，而是由 OCaml 模組決定的， 可以通過將新版本提交到區塊鏈中（並對擬議的變更投票）來升級。通過這種方式，人們將能夠通過首先部署 “vanilla” Tezos 區塊鏈，然後逐步改變所需方向的區塊解釋功能來創建自訂單鏈項目，而無需任何硬分叉。
這個想法雖然很有趣，但有明顯的缺點，它禁止在其他語言（如 C ++）中進行任何優化實現
，因此基於 Tezos 的區塊鏈註定會降低性能。我們認為通過發佈所提出的區塊解釋函數
ev_trans 的正式規範可能已經獲得了類似的結果，而不用修復特定的實現。

#### 2.9.5	Casper 31
Casper 是即將推出的乙太坊 PoS 演算法；2017年（或2018年）逐步部署，倘若成功，將會把乙太坊改為單鏈 PoS 或混合 PoW + PoS 系統，並提供智慧合約支援，將乙太坊轉變為第三代專案。

---

31 https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/

---

#### 2.9.6	比特股（BitShares）[8]；https://bitshares.org。

BitShares（2014）是基於分散式區塊鏈的交換的平臺。 它是一個沒有智慧合約的異構多塊鏈
DPoS 系統；假設區塊鏈狀態適合記憶體，它只允許一小組預定義的專用交易分片實現其高性能
，這些分片可以在 C++ 中有效實現。它也是第一個使用權益委託證明（DPoS）的區塊鏈專案，至少在某些特殊目的下證明了它的可行性。

#### 2.9.7	EOS[5]；https://eos.io。

EOS（2018 或更高版本）是一種提議的異構多鏈 DPoS 系統，支援智慧合約和消息傳遞的最小支援（在 2.8.14 中描述的意義上仍為鬆散耦合）。這是以前成功創建 BitShares 和 Steemit 項目的同一團隊的嘗試，展示了 DPoS 共識演算法的優點。可擴展性將通過為需要擴容的專案創建專用工作鏈（例如，分散式交換可能使用支持一組特殊優化專門交易的工作鏈，類似於BitShares 所做的那樣），並通過創建具有相同規則的多個工作鏈（在 2.8.10 中描述的類似的聯盟鏈）來實現。這種可擴展性方法的缺點和局限性已在 2.8.5、2.8.12 和 2.8.14討論，請參見這三部分，它們更詳細地討論了關於DPoS、分片、工作鏈之間的交互及其對區塊鏈系統可擴展性的影響。
同時，即使無法“在一個區塊鏈中創建 Facebook”（參見 2.9.13），（例如）EOS 或其他公鏈
，我們認為，對於一些高度專業、弱互動的分散式應用而言，EOS可能成為最方便的平臺，
類似於 BitShares（去中心化交易）和 SteemIt（分散式博客平臺）。

#### 2.9.8	波卡（Polkadot） https://polkadot.io/。

Polkadot（2019 年或更晚）是最精心設計和最詳細的多鏈PoS專案之一；它的開發由乙太坊聯合創始人之一領導。該項目與我們 TON區塊鏈的路線圖最接近。[事實上，我們的“漁夫（ fishermen）” 和 “提名人（nominators）” 的術語應歸功於Polkadot。]
Polkadot 是一個異構的松耦合多鏈PoS項目，使用拜占庭容錯（BFT）共識生成新區塊和主鏈
（可能是外部的——如乙太坊區塊鏈）。它還使用超立方體路由，有點像（2.4.19 中所述）
TON 的慢速版本。

它的獨特之處在於，它不僅可以創建鏈，還可以創建私有鏈。這些私有鏈也可以與其他公鏈、
Polkadot或其他鏈交互。

因此，Polkadot 可能成為大規模私有鏈的平臺，例如，銀行財團可以將其用於快速資金轉移
，或者大型公司可能使用私有鏈技術的任何其他用途。

但是，Polkadot 不支持分片，也沒有緊密耦合。這與 EOS 類似，有些妨礙它的可擴展性。
（Polkadot 可能更好一點，因為 Polkadot 使用 BFT PoS，而不是 DPoS。）

#### 2.9.9	Universa https://universa.io。

我們在這裡提到這個不尋常的區塊鏈項目，原因只有一個，是因為它是迄今為止唯一一個通過明確引用類似於我們的無限分片範式（Infinite Sharding Paradigm）的項目（參見 2.1.2）。
 
它的另一個特點是它繞過了與拜占庭容錯相關的所有複雜性，承諾只有項目信任和許可的合作夥伴才會被認可為驗證人，因此他們永遠不會提交無效的區塊。這是一個有趣的決定；然而， 它使區塊鏈項目有意中心化，而區塊鏈項目通常要避免中心化（為什麼有人會在充滿信任的中心化環境中對區塊鏈有所需求？）。

#### 2.9.10	Plasma https://plasma.io。

Plasma（2019？）是另一個乙太坊聯合創始人（領導）的非傳統區塊鏈專案。它旨在減輕乙太坊的某些局限性，而不引入分片。本質上，它是一個獨立於乙太坊的專案，引入了一個（異構的）工作鏈的層次結構，與頂層的乙太坊區塊鏈（用作外部主鏈）綁定在一起。資金可以從層次結構中頂層的任何區塊鏈轉移（從作為根的乙太坊區塊鏈開始），以及要做一些描述性工作。然後在子工作鏈中完成必要的計算（可能需要在樹下進一步轉發原始作業的部分），將結果傳遞出去，並獲取獎勵。實現一致性和驗證這些工作鏈的問題被（支付通道引發的）機制所規避，允許用戶單方面將資金從行為不當的工作鏈中提取到其上屬工作鏈（儘管速度緩慢）， 並將其資金和工作重新分配給另一個工作鏈。
通過這種方式，Plasma 可能成為與乙太坊區塊鏈綁定的分散式運算平臺，類似於“共同計算處理器”。但是，這似乎不是實現真正的通用可伸縮性的一種方法。

#### 2.9.11	專用區塊鏈項目
還有一些專用區塊鏈專案，例如 Filecoin（該系統激勵使用者提供磁碟空間來存儲願意為其付費的其他用戶的檔）、Golem（一種基於區塊鏈的算力租借平臺，用於像3D渲染這樣的專門應用）或  SONM（另一個類似的算力借貸專案）。這些專案在區塊鏈組織層面上沒有引入任何概念上新的東西；相反，它們是特定的區塊鏈應用程式，可以通過運行于通用區塊鏈的智慧合約來實現，前提是它可以提供所需的性能。因此，此類項目可能會使用現有或計畫中的區塊鏈項目之一作為其基礎，例如 EOS、Polkadot 或 TON。如果一個專案需要 “真正的” 可擴展性（基於分片），那麼最好使用 TON；如果通過定義一個自己的工作鏈系列來滿足在“聯盟” 環境中工作的內容，為其目的明確優化，它可能會選擇 EOS 或 Polkadot。

#### 2.9.12	TON區塊鏈
TON（Telegram Open Network）區塊鏈（計畫 2018 年）是本文檔中描述的項目。它只在成為第一個第五代區塊鏈項目——即 BFT PoS多鏈項目，混合同構 / 異構，支援（可分片）自訂工作鏈，具有本地分片支援，並且緊密耦合（特別是可以保留所有分片鏈一致狀態同時， 快速在分片間轉發消息）。因此，它將是一個真正可擴展的通用區塊鏈項目，本質上可以實現在區塊鏈中實現的任何應用程式。當通過 TON 專案的其他元件進行擴充時，其可能性將進一步擴大。

#### 2.9.13	“讓 Facebook 上鏈”？

有時，人們聲稱，可以在區塊鏈上建立 Facebook 規模的分散式應用程式社交網路。通常，一些區塊鏈項目會被引用作為此類應用程式的“主機（host）”。
我們不能說這在技術上不可能。當然，我們需要一個具有真正分片（即 TON）的緊密耦合的區塊鏈項目，以便這樣一個大型應用程式不會運轉太慢（例如，將一個分片鏈中使用者的消息和
 
更新傳遞給另一個分片鏈中的朋友，延遲應當在合理範圍內）。但是我們認為不需要如此，這也永遠不會達成，因為價格過高。
讓我們把“Facebook 上鏈”作為思想實驗；任何其他類似規模的專案也可以作為一個例子。一旦將 Facebook 上傳到區塊鏈中，目前由 Facebook 伺服器完成的所有操作將被序列化為某些區塊鏈中的交易（例如，TON 的分片鏈），並且將由這些區塊鏈的所有驗證人執行。如果我們希望每個區塊收集至少（立即或最終，如在 DPOS 系統中） 20 個驗證人簽名，則必須執 行每個操作，至少 20 次。類似地，Facebook 的伺服器在其磁片上保存的所有資料將保存在相應分片鏈的所有驗證人的磁片上（即至少有 20 個副本）。
因為驗證人本質上與Facebook 目前使用的那些伺服器相同（或者可能是伺服器的集群，但這不會影響這個參數的有效性），因為，我們看到在區塊鏈中運行 Facebook 相關的總硬體費用比以傳統方式實施的費用至少高 20 倍。
事實上，費用仍然會高得多，因為區塊鏈的虛擬機器比運行優化的編譯代碼的“裸 CPU”慢，並且其存儲未針對特定於 Facebook 的問題進行優化。人們可以通過製作適合 Facebook 的一些特殊交易的特定工作鏈來部分緩解這個問題；這是 BitShares 和 EOS 實現高性能的方法，也可用于 TON 區塊鏈。然而，一般的區塊鏈設計本身仍會產生一些額外的限制，例如，必須將所有操記錄為區塊中的交易，在 Merkle 樹中組織這些交易，計算和檢查它們的 Merkle 雜湊值，以進行傳播等等。
因此，一個保守的估計是，為了驗證託管Facebook規模的社交網路的區塊鏈專案，人們需要與 Facebook 現在使用的性能相同的伺服器的100倍。有些人將不得不為這些伺服器付費，要麼是擁有分散式應用程式的公司（想像在每個 Facebook 頁面上看到 700 個廣告而不是 7
個），要麼是其用戶。無論哪種方式，這似乎在經濟上都不可行。

我們認為，並不是所有內容都應該上鏈。例如，沒有必要將用戶照片保留在區塊鏈中；在區塊鏈中記錄這些照片的雜湊值並將照片保存在分散式的鏈下存儲（例如 Filecoin 或 TON 存儲） 中將是一個更好的主意。這就是為什麼 TON 不僅僅是一個區塊鏈項目，而是如第 1 章和第 4 章所述以 TON 區塊鏈為中心的幾個要素（TON P2P 網路，TON 存儲，TON 服務）的集合。
 
## 3	TON網路
任何區塊鏈專案都不僅需要規範區塊格式和區塊驗證標準，還需要一個用於傳播新區塊、發送和收集交易候選人等的網路通訊協定。換句話說，每個區塊鏈專案都必須建立專門的P2P網路。因為區塊鏈專案通常需要去中心化，所以這個網路必須是點對點的，我們不能依賴中心化的伺服器群並使用傳統的用戶端——伺服器架構，例如，傳統的線上銀行應用程式。即使輕用戶端
（如加密貨幣輕錢包智慧手機應用）必須以類似用戶端——伺服器的方式連接到全節點，假定用來連接全節點的協議足夠標準化，那麼如果先前連接的全節點發生故障，輕用戶端還可以再切換另一個全節點。

雖然可以很容易地滿足單鏈區塊鏈（如比特幣或乙太坊）的網路需求（需要構建一個 “隨機” 的點對點覆蓋網路，並通過一個gossip協議傳播所有新區塊和交易候選人），TON區塊鏈等多鏈專案的要求更高（例如，可以訂閱只有一些而不需要去不分片鏈的更新）。因此，TON區塊鏈和TON專案的網路部分部分將在這裡進行討論。

另一方面，一旦所需要用來支援TON區塊鏈的更複雜網路通訊協定到位，結果是它們很容易用於不一定與TON區塊鏈的當前直接需求相關的目的，因此它們會在TON生態系統裡提供更多的可能性和靈活性。

#### 3.1	抽象資料包表網路層（簡稱 ADNL）
構建TON網路通訊協定的基礎是（TON）抽象（資料表）網路層。它使所有節點能夠假設某些由256位 “抽象網路位址” 表示的“網路標識”，並且可以使用這些256位網路位址進行通信（給各方發送資料包表作為第一步）以識別發送方和接收方。人們不必擔心IPv4或IPv6位址、UDP 埠號等；它們會被抽象網路層隱藏。

#### 3.1.1	抽象網路位址。
一個抽象網路位址或抽象位址，或簡稱位址，是256位元整數，本質上等於256位ECC公開金鑰。公開金鑰可以任意生成，從而根據節點的喜好，創建任意多的不同網路身份。然而，必須知道相應的私密金鑰，才能接收（和解密）用於這種位址的消息。
實際上，地址本身並不是公開金鑰；相反，它是序列化的TL對象（參見 2.2.5）的 256 位雜湊（ Hash = sha256），可以根據其構造函數（前四個位元組）描述幾種類型的公開金鑰和位址。在最簡單的情況下，這個序列化的TL物件只包含一個4位元組的魔術數位和一個256位元的橢圓曲線加密
（ECC）公開金鑰；在這種情況下，位址將等於這個36位元組結構的雜湊值。然而，可以使用2048 位RSA金鑰或任何其他公開金鑰加密方案來取代。
當節點知曉另一個節點的抽象位址時，它還必須接收其 “原象”（即序列化的TL物件，其雜湊
值等於那個抽象地址），否則它將無法加密並將資料包表發送到該地址。

#### 3.1.2	較低級別的網路。UDP的實現。
從幾乎所有TON網路元件的角度來看，唯一存在的是能夠（不可靠）將資料包表從一個抽象位址發送到另一個抽象位址的網路（the Abstract Datagram Networking Layer；ADNL）。原則上，抽象資料包網路層（ADNL）可以在不同的現有網路技術上實現。但是，我們將在IPv4
/ IPv6網路（例如 Internet 或 Intranet）中通過UDP實現它，如果UDP不可用，則使用可選的TCP回退。
 
#### 3.1.3	基於UDP最簡單的ADNL的例子。
最簡單地例子是，從發送者的抽象位址向任何其他抽象位址（具有已知的原像）發送資料包表可以用以下方式實現。
假設發送者以某種方式知道擁有目的地抽象位址的接收方的IP位址和UDP埠，也知道接收方和發送方都使用的抽象位址都來源於256位ECC公開金鑰。
在這種情況下，發送者只是增加了將要通過ECC簽名（配合它的私密金鑰完成）和它的源位址
（如果接收者尚不知道源地址的原像，則是發送原像） 發送的資料包表。結果用接收者的公開金鑰加密，嵌入UDP資料包並發送到接收者的已知IP和埠。由於UDP資料包表的前256位包含接收者的抽象位址，因此接收者可以識別應使用哪個私密金鑰來解密資料包的其餘部分。只有在那之後發送者的身份才能被披露。

#### 3.1.4	寄件者的明文位址是一種安全性較低的方式。
有時，使用安全性較低的方式就足夠了，即接收者和發送者的位址以明文形式保存在 UDP 資料包中的時候； 發送方的私密金鑰和接收方的公開金鑰組合在一起，使用ECDH（橢圓曲線
Diffie-Hellman）生成一個 256 位的共用金鑰，隨後使用該共用金鑰，還有一起被使用的是未加密部分中包含的隨機256位亂數，以匯出用於加密的AES金鑰。例如，可以通過在加密之前將原始明文資料的雜湊值連接到明文來提供完整性。
這種方法的優點是，如果預計有多份資料包表在兩個位址之間切換，則只能計算一次共用金鑰
，然後進行快取記憶體； 然後，加密或解密下一個資料包表將不再需要較慢的橢圓曲線運算。

#### 3.1.5	通道和通道識別字。
在最簡單的情況下，攜帶嵌入式TON ADNL資料包表的UDP資料包表的前256位將等於接收者的地址。然而，總得來說它們構成了通道識別字。有不同類型的通道。其中一些是點對點的； 創建的雙方希望在未來交換大量資料，並生成一個共用秘鑰。實現方式包括通過交換幾個如3.1.3或3.1.4所述的加密資料包，或通過運行經典或橢圓曲線Diffie-Hellman（如果需要額外的安全性），或者只通過一方生成生成隨機共用金鑰並將其發送給另一方。
在此之後，一個通道識別碼由共用秘密與一些附加資料（如發送者和接收者的位址）組合而成
，例如通過雜湊演算法，並且該識別字被用作UDP資料包表的前256位，這些資料包表借助該共用私密金鑰加密。

#### 3.1.6	通道作為一種隧道識別字。
通常，“通道” 或 “通道識別字” 僅選擇處理接收器已知的入站UDP資料包表的方式。如果通道是接收者的抽象位址，那麼處理方法就如3.1.3或3.1.4所述；如果通道是 3.1.5 中討論的已建立的點對點通道，則處理過程在於借助共用私密金鑰對資料包表進行解密，如loc. cit.等中解釋的那樣。
特別是，當直接接收者簡單地將所接收的消息轉發給其他人——實際接收者或另一個代理時， 通道識別字實際上可以選擇 “隧道”（tunnel）。一些加密或解密步驟（讓人聯想到 “onion routing”[6] 甚至 “garlic routing”32）可能會在此過程中完成，而另一個通道識別字可能會用於重新加密的轉發資料包（例如，點對點通道可以用來將資料包轉發給路徑上的下一個接收
者）。
通過這種方式，可以在TON抽象資料包網路層的層面上添加一些對 “tunneling” 和 “proxying”
的支援——與TOR或I2P項目提供的類似——而不會影響到所有高層TON抽象資料包表網路協

---

32 https://geti2p.net/en/docs/how/garlic-routing

---

議的功能，所有高層TON抽象資料包表網路通訊協定對此添加而言都是不可知的。這是利用了
TON Proxy服務（參見 4.1.11）。

#### 3.1.7	零通道和bootstrap問題。
通常，TON ADNL節點將具有一些 “相鄰節點列表（neighbor table）”，其包含關於其他已知節點的資訊，例如它們的抽象位址及其原像（即公開金鑰）及其IP位址和UDP埠。然後它將通過使用從這些已知節點獲取的資訊作為特殊查詢的答案逐漸擴展此表，並且有時會有修剪的記錄。
但當TON ADNL節點剛啟動時，可能發生此節點不知道其他節點的情況，只知道節點的IP地址和UDP埠，而不知道其他節點的抽象地址。這種情況會在如下時候發生：例如，如果輕節點無法訪問任何先前緩存的節點以及任何硬編碼到軟體中的節點，並且必須要求用戶輸入節點的IP地址或DNS域，然後通過DNS解決 。
在這種情況下，節點將資料包發送到相關節點的特殊 “零通道”。這不需要知道接收者的公開金鑰
（但消息仍應包含寄件者的身份和簽名），因此消息無需加密即可傳輸。它通常應該僅用於獲取接收器的身份（可能是專門為此創建的一次性身份），然後以更安全的方式開始通信。
一旦知道至少一個節點，就很容易通過更多條目填充 “相鄰節點列表（neighbor table）” 和
“路由表（routing table）”，從發送到已知節點的特殊查詢答案中知道它們。
並非所有節點都需要處理發送到零通道的資料包表，但那些用作bootstrap輕用戶端的節點應該支持這個功能。

#### 3.1.8	ADNL上類似TCP的流協議。
ADNL是基於256位抽象地址的不可靠（小規模）資料包表協議，可用作更複雜網路通訊協定的基礎。例如可以使用ADNL作為IP的抽象替代物來構建類似TCP的流協議。但是TON專案的大多數元件都不需要這樣的流協定。

#### 3.1.9	RLDP或ADNL上的可靠大資料包表協議。
使用基於ADNL的可靠的任意大小的資料包表協議（稱為 RLDP）代替類似 TCP 的協議。例如，可以使用這種可靠的資料包表協議將RPC查詢發送到遠端主機並通過它們接收回復（參見 4.1.5）。

### 3.2	TON DHT：類似Kademlia的分散式雜湊表
TON分散式雜湊表（DHT）在TON專案的網路部分起著至關重要的作用，用於定位網路中的其他節點。例如，一個想要將交易提交到分片鏈的用戶端可能想要找到該分片鏈的驗證人或校驗者，或者至少某個可能將用戶端的交易中繼到校驗者的節點。這可以通過在TON DHT中查找特殊鍵來完成。TON DHT的另一個重要應用是它可以用來快速填充新節點的相鄰節點列表（參見 3.1.7），只需查找隨機金鑰或新節點的地址即可。如果一個節點對其入站資料包表使用代理和隧道，則它在TON DHT中發佈隧道識別字及其入口點（例如，IP位址和UDP埠）； 緊接著希望將資料包發送到該節點的所有節點將首先從DHT獲得聯繫資訊。
TON DHT是類似Kademlia的分散式雜湊表系列的成員[10]。

#### 3.2.1	TON DHT的金鑰。
TON DHT的金鑰是簡單的256位元整數。在大多數情況下，它們被計算為TL序列化物件的SHA256值（參見2.2.5），稱為金鑰的原像或金鑰的描述。在某些情況下，TON網路節點的
 
抽象位址（參見3.1.1）也可以用作TON DHT的金鑰，因為它們也是256位的，它們也是TL序列化物件的雜湊值。例如，如果節點不害怕公佈其IP位址，任何知道其抽象位址的人都可以找到它，方法是簡單地將該位址作為DHT中的金鑰來查找地址。

#### 3.2.2	DHT的值。
分配給這些256位金鑰的值基本上是有限長度的任意位元組字串。這種位元組字串的解釋由相
應金鑰的原像決定；通常通過查找金鑰的節點和存儲金鑰的節點一起才能知道金鑰的值。

#### 3.2.3	DHT的節點。半永久性網路身份。
TON DHT的金鑰值映射保留在DHT的節點上——基本上是TON網路的所有成員。為此，除了3.1.1中描述的任何數量的短暫和永久抽象位址之外，TON網路的任何節點（可能除了一些非常輕的節點）至少具有一個 “半永久位址”，也將其標識為TON DHT的成員。這個半永久地址或DHT地址不應該經常更改，否則其他節點將無法找到他們正在尋找的金鑰。如果節點不想顯示其 “真實” 標識，則它會生成一個單獨的抽象位址，僅用於參與DHT。但是，此抽象地址必須是公共的，因為它將與節點的IP位址和埠相關聯。

#### 3.2.4	Kademlia距離。
現在我們有256位金鑰和256位（半永久）節點地址。我們在 256 位序列集上引入所謂的XOR
距離或Kademlia距離dK，由下式給出

dK (x, y) := (x ⊕ y)	解釋為一個未簽名的256位元整數	(25)

這裡x⊕y表示相同長度的兩位序列的按位異或（bitwise eXclusive OR）（或 XOR）。Kademlia距離在所有256位元序列的集合2256上引入度量。尤其是，如果當且僅當x = y, d (x,y) = dK (y, x), 以及dK (x, z) ≤ dK (x, y) + dK (y, z)時，得出結論dK(x,y) = 0。另一個重要特性是在距x 的任何給定距離處只有一個點：dK (x, y) = dK (x, y′) ，暗含了y = y′。
#### 3.2.5	類似Kademlia的DHTs和TON DHT。
如果期望將Kademlia上的最近節點s的金鑰值K保持為K（即 ，從其地址到K的帶有最小
Kademlia距離最小的s節點。），那麼我們說帶有256位金鑰和256位節點地址的分散式雜湊表
（DHT）是類似Kademlia的 DHT。
這裡是一個小參數，比如當s = 7時提高DHT的可靠性（如果我們只將金鑰保存在一個節點上
——最接近K的那個節點，當那個節點離線時，那個金鑰的值就會丟失）。
根據這個定義，TON DHT是類似Kademlia的DHT。它是通過3.1中描述的ADNL協議實現的。

#### 3.2.6	Kademli路由表。
參與Kademlia-like DHT的每個節點通常都維護一個Kademlia路由表。在TON DHT的情況下， 它由n = 256個桶（buckets）組成，編號從0到n-1。第i-th個桶將包含關於一些已知節點的資訊（“最佳” 節點的一個固定數量t，可能還有一些額外的候選人），這些已知節點位於距離節點地址a的Kademli 距離2i到2i+1−1之間33。這個資訊包括它們的（半永久）位址、IP 地址和UDP埠，以及一些可用性資訊，如最後一次ping的時間和延遲。

---

33 如果存儲桶中有足夠多的節點，則可以進一步細分為例如八個子桶，這取決於Kademlia距離的前四位。這會加快DHT查找速度。

---

當Kademlia節點瞭解其他Kademlia節點作為查詢結果時，它將這個查詢結果包含在其路由表的合適桶中，首先作為候選人。然後，如果該桶中的一些 “最佳” 節點失敗（例如，長時間不回應ping查詢），則可以用一些候選人替換它們。通過這種方式，Kademlia路由表保持填充狀態。
來自Kademlia路由表的新節點也包含在3.1.7中描述的ADNL相鄰節點列表中。如果經常使用來自Kademlia路由表的桶中的 “最佳” 節點，那麼從3.1.5中中描述的意義上來說，可以建立一個通道以便於加密資料報表。
TON DHT的一個特殊功能是它嘗試選擇往返延遲最小的節點作為Kademlia路由表的桶的 “最佳” 節點。


#### 3.2.7	（Kademlia網路查詢。）Kademlia節點通常支援以下網路查詢：
•	PING——檢查節點可用性。
•	STORE (key,value)——要求節點將value保持為金鑰key的值。對於TON DHT， STORE查詢稍微複雜一些（參見 3.2.9）。
•	FIND_NODE (key,l)——要求節點將Kademlia最近的已知節點l（從其Kademlia路由表）返回到金鑰。
•	Find_VALUE (key, l)——與上面相同，但如果節點知道與金鑰key對應的值，則只返回到該值。

當任何節點想要查找金鑰K的值時，它首先創建s'節點的集合S（對於s'的一些小值，比如s'= 5
），S是已知節點中就Kademlia距離而言最接近K的（例如它們來自Kademlia路由表）。然後向它們中的每一個發送Find_Value查詢，並且在它們的答案中提到的節點也包含在S中。如果之前沒有這樣做，那麼來自S的s'節點（最接近於K）也被發送 Find_Value查詢，並且該過程一直持續到找到值或集合S停止增長為止。這是就Kademlia距離而言，距離K最近的節點的一種 “集束搜索（beam search）”。
如果要設置某個金鑰K的值，使用Find_Node查詢而不是Find_Value查詢，則對 s'≥s 運行相同的過程，用來查找距離K最近的節點。之後，STORE查詢發送給所有這些節點。
在實現類似Kademlia的DHT時有一些不太重要的細節（例如，任何節點都應該查找最近的節點s，比如每小時一次，並通過STORE查詢重新發佈所有存儲的金鑰）。我們暫時會忽略它們。

#### 3.2.8	啟動Kademlia節點。
當Kademlia節點聯網時，它首先通過查找自己的地址來填充其Kademlia路由表。在此過程中
，它標識出距離自身最近的節點s。它可以從這些節點中下載所有已知的(key,value)對，以填充它的部分DHT。

#### 3.2.9	在TON DHT中存儲值。
在TON DHT中存儲值與一般像Kademlia的DHT略有不同。當有人希望存儲一個值時，她必須不僅要向STORE查詢提供金鑰K本身，還要提供其原像——例如TL序列化的字串（開頭帶有幾個預定義的TL構造函數的其中一個），原像包含對字串的 “ 描述 “。稍後由節點保存此金鑰描述以及金鑰和值。
金鑰描述了所存儲物件的 “類型欄位”，其 “所有者” 以及未來更新時的 “更新規則”。所有者通常通過金鑰描述中包含的公開金鑰來標識。如果包含公開金鑰，通常只接受由相應私密金鑰簽名的更新。存儲物件的 “類型欄位” 通常只是一個位元組字串。然而，在某些情況下，它可能更複雜——例如，輸入隧道描述（參見 3.1.6）或節點位址的集合。
 
“更新規則” 也可以不同。在某些情況下，假使新值由所有者簽名（簽名必須保留為值的一部分
，之後由其他任何節點在獲取金鑰值之後檢查），更新規則只允許用新值替換舊值。在其他情況下，舊值會以某種方式影響新值。例如，它可以包含序號，只有在新序號較大時才會覆蓋舊值（以防止重新操作的攻擊）。

#### 3.2.10	TON DHT中的分散式 “流追蹤器”
另一個有趣的情況是，當值包含節點列表時——可能帶有其IP位址和埠，或僅帶有其抽象位址——並且 “更新規則” 在於將請求者包括在此列表中，假使她可以確認她的身份。
該機制可以用於創建分散式 “流追蹤器”，在“流追蹤器”上，對某個 “流”（檔）感興趣的所有
節點可以找到對相同的流感興趣或已經具有副本的其他節點。
TON存儲（參見 4.1.8）使用該技術來查找具有所需檔副本的節點（例如，分片鏈或舊塊的狀態的快照）。但是，更重要的用途是創建 “覆蓋組播子網” 和 “網路興趣小組”（參見 3.3）。這個想法是只有一些節點對特定分片鏈的更新感興趣。如果分片鏈的數量變得非常大，甚至找到對同一分片感興趣的一個節點可能會變得複雜。這種 “分散式流追蹤器” 提供了一種查找這些節點的便捷方法。另一種選擇是從驗證人請求它們，但這不是一種可擴展的方法，驗證人可能選擇不回應來應對任意未知節點的查詢。

#### 3.2.11	Fall-back keys

到目前為止所描述的大多數 “金鑰類型”，用它們的TL描述來說具有額外的32位元整數欄位，通常等於零。然而，如果無法從TON DHT中檢索或更新通過雜湊描述獲得的金鑰，則增加該欄位中的值，並進行新的嘗試。以這種方式，通過在受到攻擊的金鑰附近創建許多抽象位址並控制相應的DHT節點，我們不能 “捕獲” 和 “審查” 金鑰（即執行金鑰保留的攻擊）。

#### 3.2.12	定位服務。
某些服務位於TON網路中，並通過如3.1中描述的TON ADNL（基於其構建的高級協議）提供
，這些服務可能希望在某處發佈其抽象位址，以便其客戶知道在哪裡找到它們。
然而，在TON區塊鏈中發佈服務的抽象位址可能不是最好的方法，因為抽象位址可能需要經常更改，也因為為了可靠性或負載平衡的目的而提供多個位址是有意義的。
一種替代方法是將公開金鑰發佈到TON區塊鏈中，並使用一個特殊的DHT金鑰，表明公開金鑰作為TL 描述字串中的 “所有者”（參見 2.2.5），用來發佈 服務的抽象位址的最新列表。這是利用Ton服務的方法之一。

#### 3.2.13	定位TON區塊鏈帳戶的所有者。
在大多數情況下，TON區塊鏈帳戶的所有者不希望與抽象網路位址相關聯，尤其是 IP 地址， 因為這可能會侵犯他們的隱私。但是，在某些情況下，TON區塊鏈帳戶的所有者可能希望發佈可以聯繫她的一個或多個抽象位址。
典型的情況是TON支付 “閃電網路” 中的節點（參見 5.2），也就是即時加密貨幣轉帳平臺。公共TON支付節點可能不僅希望與其他對等節點建立支付通道，而且還要發佈抽象網路位址， 這個地址可用來在後續沿著已建立的支付通道轉帳支付時聯繫它。
一種選擇是在創建支付通道的智慧合約中包含抽象網路位址。更靈活的選擇是在智慧合約中包含公開金鑰，然後按照 3.2.12 中的說明使用DHT。
最自然的方法是使用控制TON區塊鏈中帳戶的相同私密金鑰，用來簽署和發佈TON DHT中與該帳戶關聯的抽象位址的更新。這幾乎與3.2.12中描述的方式相同；但是，使用的DHT金鑰需要一
 
個特殊的金鑰描述，這個私密金鑰描述只包含account_id本身，等同於 “account description” 的
SHA256值，該值包含帳戶的公開金鑰。包含在此DHT金鑰值中的簽名也將包含帳戶描述。
通過這種方式，用於定位TON區塊鏈帳戶的一些所有者的抽象網路位址這一機制得以建立。

#### 3.2.14	找到抽象地址的位置。
請注意，TON DHT雖然通過TON ADNL實現，但它本身也被TON ADNL用於多種用途。
其中最重要的是從256位抽象位址開始定位節點或其連絡人資料。這是必要的，因為即使沒有提供其他資訊，TON ADNL也應該能夠將資料包表發送到任意的256位抽象地址。
為此，在DHT中將256位抽象位址簡單地作為金鑰被查找。具有該位址的節點（即，使用該位址作為公共半永久DHT位址）被搜索到，在這種情況下，可以知曉其IP位址和埠；或者，可以檢索輸入隧道描述作為所討論的金鑰的值，由正確的私密金鑰簽名，在這種情況下，該隧道描述將用於將ADNL資料包表發送到預期的接收者。
請注意，為了使抽象位址 “public”（可從網路中的任何節點訪問），其所有者必須將其用作半永久性DHT地址，或者發佈（在DHT中，關鍵值等於所考慮的抽象位址）帶有另一個公共抽象位址（例如，半永久位址）的隧道描述輸入，這個公共抽象位址作為隧道的入口點。另一種選擇是簡單地發佈其IP位址和UDP埠。

### 3.3	覆蓋網路（Overlay Networks） Multicasting Messages）
在像TON區塊鏈這樣的多鏈系統中，甚至完整節點通常也只對獲取某些分片鏈的更新（即新區塊）感興趣。為此，必須在TON網路內部建立一個特殊的覆蓋（子）網路，位於3.1 中討論的ADNL協議之上，每個分片鏈都有一個。
因此，構建對任意覆蓋子網的需求在增加，構建任意覆蓋子網對任何願意參與的節點都開放。基於ADNL的特殊gossip協定將在這些覆蓋網路中運行。特別是，這些gossip協議可用於在這種子網內傳播（廣播）任意資料。

#### 3.3.1	覆蓋網路。
覆蓋（子）網路簡單地是在一些較大網路內實現的（虛擬）網路。 通常，只有較大網路的一些節點參與覆蓋子網，並且這些節點之間只有一些 “links” ，不管是實體的還是虛擬的，才是覆蓋子網的一部分。
通過這種方式，如果包含網路被表示為圖形（在資料包表網路的情況下可以使用完整的圖形， 例如 ADNL，這樣任何節點都可以輕鬆地與任何其他節點通信），覆蓋子網路是這個圖形的子圖。
在大多數情況下，覆蓋網路使用基於較大網路的網路通訊協定構建的一些協議來實現。它可以使用與較大網路相同的位址，或使用自訂位址。

#### 3.3.2	TON中的覆蓋網路。
TON中的覆蓋網路建立在3.1中討論的ADNL協議之上；它們也使用256位ADNL抽象位址作為
覆蓋網路中的位址。每個節點通常選擇它的一個抽象位址加倍作為在覆蓋網路中的位址。
與ADNL相比，TON覆蓋網路通常不支援將資料包表發送到任意其他節點。相反，在一些節點之間建立一些 “半永久連結”（相對於所考慮的覆蓋網路稱為 “相鄰節點”），並且消息通常沿著這些連結（即從一個節點到其中一個相鄰節點）被轉發。以這種方式，TON覆蓋網路是ADNL 網路的（完整）圖形內的（非完整）子圖。
 
可以使用專用的對等ADNL通道來實現與TON覆蓋網路中的相鄰節點的連結（參見 3.1.5）。覆蓋網路的每個節點維護一份相鄰節點的清單（與覆蓋網路有關），包含它們的抽象位址（用於在覆蓋網路中識別它們）和一些連結資料（例如，用於與它們通信的ADNL通道）。

#### 3.3.3	私人和公共覆蓋網路。
一些覆蓋網路是公共的，這意味著任何節點都可以隨意加入它們。其他是私有的，意味著只允許某些節點被接納（例如，那些可以證明其身份為驗證人的節點）。一些私有覆蓋網路甚至可以為 “general public” 所知。這種覆蓋網路的資訊僅對某些可信節點可用；例如，它可以使用公開金鑰加密，並且只有具有相應私密金鑰副本的節點才能解密此資訊。

#### 3.3.4	中心化控制的覆蓋網路。
一些覆蓋網路是中心化控制的，由一個或多個節點控制，或由一些廣為人知的公開金鑰所有者控制。其他的是去中心化的，這意味著沒有特定的節點負責它們。

#### 3.3.5	加入覆蓋網路。
當一個節點想要加入一個覆蓋網路時，它首先必須知道它的256位元網路識別字，通常等於覆蓋網路描述的SHA256——這是一個序列化物件的TL語言（參見2.2.5），它可能包含例如，覆蓋網路的中心權威（即其公開金鑰，可能是抽象地址34）；具有覆蓋網路名稱的字串；如果這是與分片相關的覆蓋網路，也可以是TON 區塊鏈分片識別字，等等。
有時可以從網路識別字開始恢復覆蓋網路描述，只需在TON DHT中查找即可。在其他情況下
（例如，對於私有覆蓋網路），我們必須獲得網路描述以及網路識別字。

#### 3.3.6	找到覆蓋網路的一個成員的位置。
在節點獲知其想要加入的覆蓋網路的網路識別字和網路描述之後，它必須至少找到屬於該網路的一個節點。
對於不想加入覆蓋網路但只想與之通信的節點，也需要這樣做；例如，可能存在專用於收集和傳播特定分片鏈的交易候選人的覆蓋網路，並且用戶端可能想要連接到該網路的任何節點以建議建議。
用於定位覆蓋網路的成員的方法在該網路的描述中定義。有時（特別是對於私人網路絡），我們必須已經知道能夠加入的成員節點。在其他情況下，一些節點的抽象位址包含在網路描述中。更靈活的方法是在網路描述中僅指示負責網路的中心機構，然後通過由該中央機構簽名的某些DHT金鑰的值來獲得抽象地址。
最後，真正去中心化的公共覆蓋網路可以使用3.2.10中描述的 “分散式流追蹤器” 機制，也可以在TON DHT的幫助下實現。

#### 3.3.7	找到覆蓋網路的更多成員。創建連結。
一旦找到了覆蓋網路的一個節點，可以向該節點發送一個特殊的查詢，要求提供其他成員的列表，例如，被查詢節點的相鄰節點，或者隨機選擇其中一個節點。
這使得加入成員能夠通過選擇一些新知曉的網路節點並建立到它們的連結（例如3.3.2中概述的專用ADNL點對點通道）來填充關於覆蓋網路的 “鄰接（adjacency）” 或 “相鄰節點列表（ neighbor list）”。之後，將向所有相鄰節點發送特殊消息，表明新成員已準備好在覆蓋網路中工作。相鄰節點包含它們在相鄰節點清單中的新成員的連結。

---

34 或者，如3.2.12中所述的那樣，抽象位址可以存儲在DHT中。

---

#### 3.3.8	維護相鄰節點列表。
覆蓋網路節點必須時不時更新它的相鄰節點列表。一些相鄰節點，或者至少是它們的連結（通道）可能會停止回應；在這種情況下，必須將這些連結標記為 “暫停（suspended）”，必須做一些重新連接到此類相鄰節點的嘗試，並且如果這些嘗試失敗，則必須銷毀連結。
另一方面，每個節點有時會從隨機選擇的相鄰節點請求它的相鄰節點清單（或做部分隨機選 擇），方法是通過向它添加一些新發現的節點，並刪除一些舊節點，這個過程可以是隨機的， 也可以取決於它們的回應時間和資料包丟失統計資訊。


#### 3.3.9	覆蓋網路是一個隨機子圖。
通過這種方式，覆蓋網路是ADNL網路裡的隨機子圖。如果每個頂點的度數至少為3（例如， 如果每個節點連接到至少三個相鄰節點），則該隨機圖會以幾乎為1的概率這種大家都知道的方式連接。更準確地說，帶有n個頂點隨機圖的斷鏈的概率是極小的，如果n ≥ 20，則可以完全忽略這個概率（當然，當不同分片間的節點沒有機會互相瞭解時，這不適用於全域網路磁碟分割的情況）。在另一方面，如果 n 小於 20，就足以要求每個頂點有例如至少十個相鄰節點。

#### 3.3.10	TON覆蓋網路經過優化，可降低延遲。
TON覆蓋網路優化了由下述之前的方法生成的 “隨機” 網路圖。每個節點都嘗試保留至少三個帶有最小往返時間的相鄰節點，並很少改變這個 “快相鄰節點” 的列表。同時，它還至少有三個完全隨機選擇的 “慢相鄰節點”，因此覆蓋網路圖總是包含一個隨機子圖。這是保持連線性並防止將覆蓋網路分成幾個未連接的區域子網所必需的。至少三個帶有中間往返時間的“中間相鄰節點”也會被選擇和保留，它們受限於一定的常數（實際上是快相鄰節點和慢相鄰節點的往返時間的一種函數）。
通過這種方式，覆蓋網路的圖形仍然保持足夠的隨機性用來連接，但是對降低延遲性和提高輸送量做了優化。

#### 3.3.11	覆蓋網路中的gossip協定。
覆蓋網路習慣於運行所謂的一種gossip協定，同時讓每個節點僅與其相鄰節點交互，gossip協定得以實現一些全域目標。例如，有一些gossip協議用來構建一個大致清單，這個清單包括
（不是很大的）的覆蓋網路的所有成員，或者用來計算一個（任意大的）覆蓋網路成員的大概數，在每個節點上只使用有限的記憶體量（細節參見 [15, 4.4.3] or [1]）。

#### 3.3.12	覆蓋網路作為廣播域。
在覆蓋網路中運行的最重要的gossip協定是廣播協定（broadcast protocol），旨在將廣播消息傳播給所有其他節點，這些廣播消息由網路的任何節點或者可能是指定的發送方的一個節點生成。
實際上有幾種廣播協議，針對不同的用例進行了優化。最簡單的一種是接收新廣播消息並將它們中繼到所有相鄰節點，這些相鄰節點還沒有獨立發送該消息副本過。

#### 3.3.13	更複雜的廣播協議。
某些應用可能需要更複雜的廣播協定。例如對於發送量級比較大的廣播消息，向相鄰節點發送不是新接收的消息本身，而是發送其雜湊（或新消息的雜湊集合）是合乎情理的。在知道了先
 
前看不見的消息的雜湊之後，相鄰節點可以自己請求消息，例如使用3.1.9中討論的可靠的大資料包表協議（RLDP）進行傳輸。這樣，新消息將僅從一個相鄰節點中下載。

#### 3.3.14	檢查覆蓋網路的連線性。
如果存在一個已知節點（例如覆蓋網路的 “所有者” 或 “創造者”）必須在這個覆蓋網路中，那麼這個覆蓋網路的連線性可以被檢查。然後，所討論的節點時不時地廣播包含當前時間、序號及其簽名的短消息。任何其他節點可以確定它仍然連接到覆蓋網路，如果它不久前已經收到這樣的廣播。該協議可以擴展到幾個眾所周知的節點的用例；例如它們都將發送此類廣播，並且所有其他節點都想要從超過一半的眾所周知的節點接收廣播。
在用於傳播特定分片鏈的新區塊（或僅新區塊頭）的覆蓋網路這一例子中，節點用來檢查連接線的一個好方法是追蹤截至目前接收的最新區塊。因為區塊通常每五秒生成一次，如果說超過30秒都沒有收到新區塊，則該節點可能已經與覆蓋網路斷開連接。

#### 3.3.15	流媒體廣播協議。
最後，還有一個用於TON覆蓋網路的流媒體廣播協議，例如用於在某些分片鏈（“shardchain 任務組”）的驗證人中宣傳候選區塊，當然驗證人也會為此目的創建一個私有覆蓋網路。可以使用相同的協定將新的分片鏈區塊傳播到該分片鏈的所有完整節點。
該協議已在2.6.10中概述：新的（大）廣播消息被分成例如N個一千位元組的塊；通過諸如Reed-Solomon或噴泉碼（例如，RaptorQ代碼 [9] [14]）之類的糾刪碼將這些塊的序列增加到M ≥ N的塊，並且這些M塊被資料流到所有相鄰節點，按區塊編號昇冪排列。參與的節點收集這些塊直到它們可以恢復原始的大消息（為此一個節點必須成功接收至少N個區塊），然後指示它們的相鄰節點停止以流的方式發送新塊，因為現在這些節點可以自己生成後續的塊，並擁有原始消息的副本。這些節點繼續以流的方式生成後續塊並將它們發送到它們的相鄰節點， 除非相鄰節點反過來表明不再需要發送。
以這種方式，節點在進一步傳播之前不需要完整地下載大消息。這可以最大限度地減少廣播延
遲，尤其是與3.3.10。中描述的優化結合使用時。

#### 3.3.16	基於現有的覆蓋網路構建新的覆蓋網路。
有時人們不想從頭開始構建覆蓋網路。相反已知一個或多個先前存在的覆蓋網路，並且預計新覆蓋網路的成員資格與這些覆蓋網路的組合成員資格顯著重疊。
當一個TON分片鏈被分成兩個，或者兩個兄弟分片鏈被合併為一個時，就會出現一個重要的例子（參見2.7）。在第一種情況下，必須為每個新的分支鏈構建用於將新塊傳播到完整節點的覆蓋網路；然而，可以預期每一個新的覆蓋網路都包含在原始分片鏈的區塊傳播網路中（並且包括其大約一半的成員）。在第二種情況下，用於傳播合併分片鏈的新塊的覆蓋網路，將大概包含兩個覆蓋網路成員的並集，這兩個覆蓋網路與兩個並聯的兄弟鏈有關。
在這種情況下，新覆蓋網路的描述可以包含對相關現有覆蓋網路清單的顯式或隱式引用。希望加入新覆蓋網路的節點可以檢查它是否已經是其中一個現有網路的成員，並且在這些網路中查詢它們的相鄰節點是否也對新網路感興趣。在肯定答覆的情況下，可以為此類相鄰節點建立新的點對點通道，並且這些通道可以包含在相鄰節點清單中用於新覆蓋網路。
這種機制並不完全取代3.3.6和3.3.7中描述的一般機制；相反，它們都是並行運行的，用於填充相鄰節點列表。這是為了防止無意中將新的覆蓋網路分成幾個未連接的子網。

#### 3.3.17	帶有覆蓋網路的覆蓋網路。
另一個有趣的案例是TON支付（TON Payments）的實施（即用於即時鏈下價值轉移的 “閃電
網路”；參見 5.2）。在這種情況下，首先構建包含 “閃電網路” 的所有傳輸節點的覆蓋網路。
 
然而，其中一些節點已在區塊鏈中建立了支付通道；除了是3.3.6、 3.3.7和3.3.8中描述的一般覆蓋網路演算法選擇的任何 “隨機” 相鄰節點之外，它們必須始終是該覆蓋網路中的相鄰節點。這些相鄰節點（帶有已建立的支付通道）的 “永久連結” 用於運行特定的閃電網路通訊協定，從而有效地在包含的（最常連接的）覆蓋網路內創建覆蓋子網（如果出現問題，不一定會連接）。



## 4	TON 服務和應用
我們已經詳細討論了 TON 區塊鏈和 TON Network 技術。 現在我們來解釋一些將它們組合在一起以創建各種服務和應用程式的方法，並討論 TON 專案本身從一開始或稍後將會提供給大家的一些服務。

### 4.1	TON
我們首先討論如何在 TON 生態系統內實現不同的區塊鏈和網路相關的應用程式和服務。 首先按順序進行簡單分類：

#### 4.1.1	應用和服務。
我們將交替使用 “application （申請）” 和 “service （服務）”。 但它們存在一種微妙且有些模糊的區別：應用程式通常直接向人類使用者提供某些服務，而服務通常被其他應用程式和服務利用。 例如，TON Storage 是一項服務，因為它旨在為其他應用程式和服務保留檔，即使人類用戶也可以直接使用它。 一個假設的 “區塊鏈中的 Facebook”（參見 2.9.13）或 Telegram messenger，如果通過 TON Network 提供（即實施為 “ton-service”；參見 4.1.6），則更像是一個應用程式。即使某些 “機器人(bots)” 可能在沒有人為干預的情況下自動訪問它。

#### 4.1.2	應用的位置：鏈上，鏈下或混合。
為 TON 生態系統設計的服務或應用程式需要保留其資料並將資料處理到某處。 這就導致了以下的應用程式（和服務）的分類：
•	鏈上應用程式（參見 4.1.4）：所有資料和處理都在 TON Blockchain中。
•	鏈下應用程式（參見 4.1.5）：所有資料和處理都在 TON 區域鏈之外，在通過 TON Network 提供的伺服器上。
•	混合應用程式（參見 4.1.7）：部分（但不是全部）資料和處理都在 TON Blockchain中；其餘的是通過 TON Network 提供的鏈下伺服器。

#### 4.1.3	中心化：中心化的和去中心化的或分散式應用程式。
另一個分類標準是應用程式（或服務）是依賴於中心化伺服器集群，還是真正的  “分散式的
（參見 4.1.9）。 所有鏈上應用程式都自動去中心化和分發。 鏈下和混合應用可能表現出不同程度的中心化。現在讓我們更詳細地考慮上述可能性。

 
#### 4.1.4	
。
 
“鏈上” 應用程式：駐留在區塊鏈中的分散式應用程式或 “DApps”
 
#### 4.1.2 中提到的一種可能的方法是在 TON Blockchain中完全部署 “分散式應用程式”（通常簡稱
為 “DApp”），作為智能合約或智慧合約的集合。所有資料將作為這些智慧合約的永久狀態的
 
一部分保留，並且與項目的所有交互將通過發送到這些智慧合約或從這些智慧合約接收的（
TON Blockchain）消息來完成。
我們已經在 2.9.13 中討論過這種方法有其缺點和局限性，但也有其優點：這樣的分散式應用程式不需要運行伺服器或存儲其資料（它在 “區塊鏈” 中運行——即在驗證人的硬體上運行）
，並享有區塊鏈極高（拜占庭）的可靠性和可訪問性。這種分散式應用程式的開發人員不需要購買或租用任何硬體；他需要做的就是開發一些軟體（即智慧合約的代碼）。在那之後，她將有效地從驗證人那裡租用計算能力，並以 Grams 的形式支付它，無論是她自己支付還是讓用戶買單。

 
#### 4.1.5	純粹的網路服務：“ton-sites”
 
“ton-services”。
 
另一個極端的選擇是在某些伺服器上部署服務，並通過 3.1 中描述的 ADNL 協議將其提供給使用者，也可以使用一些更高級別的協議，如 3.1.9 中討論的 RLDP，可用於以任何自訂格式向五福發送 RPC 查詢並獲取這些查詢的答案。 這種情況中，該服務將完全處於鏈下，並將駐留在 TON Network 中，幾乎不使用 TON Blockchain。
TON Blockchain可能僅用於定位抽象位址或服務的位址，如 3.2.12 中所述，可能借助于諸如TON DNS（參見 4.3.1）之類的服務來促進域的翻譯——例如翻譯人類可讀的字串到抽象位址。
在某種程度上，ADNL 網路（即 TON Network ）類似於隱形互聯網項目（I2P），這種（幾乎）純粹的網路服務類似於所謂的 “eep-services”（即具有一個I2P -位址作為其入口點，並通過I2P網路提供給用戶端）。我們會說，駐留在 TON Network 中的這種純粹的網路服務是“ton-services”。
“eep-service” 可以實現 HTTP 作為其用戶端——伺服器協議；在 TON Network 環境中， “ton-services” 可能只是使用 RLDP（參見 3.1.9）資料包來傳輸 HTTP 查詢和回應。如果它使用 TON DNS 允許通過人類可讀的功能變數名稱查找其抽象位址，那麼對網站的類比就變得幾乎完美了。甚至可以編寫一個專門的流覽器，或者在用戶機器上本地運行的特殊代理（“ton-proxy”）
，從用戶使用的普通 Web 流覽器接受任意 HTTP 查詢（一旦是本地 IP 位址和 TCP 埠）將代理輸入到流覽器的配置中，並通過 TON Network 將這些查詢轉發到服務的抽象位址。然後
，用戶將具有類似于萬維網（WWW）的流覽體驗。
在I2P生態系統中，這種 “eep-services” 被稱為 “eep-sites”。人們也可以在 TON 生態系統中輕鬆創建 “ton-sites”。這在某種程度上得益於 TON DNS 等服務的存在，TON DNS 利用 TON Blockchain和 TON DHT 將（TON）功能變數名稱轉換為抽象位址。

 
#### 4.1.6	Telegram Messenger 作為 ton-service；MTProto
 
RLDP。
 
順便一提，Telegram Messenger 35用於用戶端——伺服器交互的 MTProto36協定可以很容易地嵌入到 3.1.9 中討論的 RLDP 協議中，從而有效地將Telegram轉換為 ton-service。 由於TON Proxy 技術可以透明地為 ton-site 或 ton-service 的最終用戶開啟，實施的程度低於RLDP 和 ADNL 協議（參見 3.1.6），這將使得Telegram能夠有效地不可阻止。當然，其他消息和社交網路服務也可能從這項技術中受益。

#### 4.1.7	混合服務：部分鏈下，部分鏈上。
有些服務可能採用混合方法：做大部分鏈下處理，但也有一些鏈上部分（例如向使用者登記他們的義務，反之亦然）。通過這種方式，部分狀態仍將保留在 TON Blockchain中（即不可變的公共帳本），並且服務或其使用者的任何不當行為都可能受到智慧合約的懲罰。

---

35 https://telegram.org/
36 https://core.telegram.org/mtproto

---

#### 4.1.8	示例：保持文件在鏈下；TON Storage。
TON Storage 提供了這種服務的一個例子。在最簡單的形式中，它允許用戶通過保持鏈上只存儲要存儲的檔的雜湊值來連結存儲檔，並且可能是一個其中一些其他方同意在預先商定的費用和時間內保留有問題的檔地智慧合約。實際上，檔可以被細分為一些小尺寸（例如
，1 千位元組）的塊，通過諸如 Reed-Solomon 或噴泉碼的擦除代碼來增強，可以為增強的塊序列構造 Merkle tree hash。 這個 Merkle tree hash可以在智慧合約中發佈，而不是與檔的通常hash一起發佈。這有點讓人聯想到檔存儲在 torrent 中的方式。
一種更簡單的存儲檔形式是完全鏈下的：本質上是為新檔創建一個 “torrent”，並使用TON DHT 作為此 torrent 的 “分散式 torrent 追蹤器”（參見 3.2.10）。對於流檔，這實際上可能非常有效。但沒有獲得任何可用性的保證。例如，一個假設的 “區塊鏈 Facebook”（參見2.9.13），可能會選擇將其用戶的個人資料照片完全脫離這種 “torrent”，這將可能會令普通
（不是特別受歡迎的）用戶失去其照片，或至少有可能無法長時間呈現這些照片。 TON Storage 技術主要是鏈下的，但使用鏈上智慧合約來強制存儲檔的可用性，可能更適合這項任務。

#### 4.1.9	“霧服務”。
到目前為止，我們已經討論了中心化混合服務和應用。雖然他們的鏈上元件以去中心化和分佈的方式處理，但他們的鏈下元件依賴於服務提供者的以通常的中心化方式控制的一些伺服器。算力可能來自某一家大公司提供的雲計算服務，而非某些專用伺服器。但是，這不會導致服務的鏈下元件的去中心化。
實現服務的鏈下元件的區中心方法在於創建一個市場，任何擁有所需硬體並願意租用其計算能力或磁碟空間的人都會向需要它們的人提供服務。
例如，可能存在一個註冊表（也可能稱為 “market” 或 “exchange”），其中所有對保持其他用戶的檔感興趣的節點都會發佈其聯繫資訊，以及它們的可用存儲容量，可用性策略和價格。需要這些服務的人可能會來查找，如果對方同意，則在區塊鏈中創建智慧合約並上傳檔以進行離線存儲。通過這種方式，像 TON Storage 這樣的服務變得真正分散，因為它不需要依賴任何集中的伺服器集群來存儲檔。

#### 4.1.10	“霧計算（fog computing）” 平臺作為分散的混合服務。
當想要執行某些特定計算（例如 3D 渲染或訓練神經網路）時，這種分散的混合應用的另一個例子就出現了，並且通常需要特定且昂貴的硬體。 那些擁有這種設備的人可能通過類似的“exchange” 提供他們的服務，而需要這些服務的人會租用相關設備，雙方的義務通過智慧合約登記。 這類似於 “霧計算” 平臺，如 Golem（https://golem.network/ ）或 SONM（ https://sonm.io/ ），的承諾交付。

#### 4.1.11	示例：TON Proxy 是霧服務。
TON 代理提供了霧服務的另一個示例，其中希望提供其服務（有或沒有補償）作為 ADNL 網路流量的隧道的節點可能會註冊，而需要它們的節點可能會根據價格、延遲、和頻寬選擇其中一個節點。之後就可以使用由 TON Payments 提供的支付通道來處理那些代理服務的小額支付，例如每收集 128 KiB 就付一次款。

#### 4.1.12	示例：TON Payments 是一項霧服務。
TON 支付平臺（參見 5）也是這種去中心化的混合應用的一個例子。
 
### 4.2	連接用戶和服務提供者
我們在 4.1.9 中已經看到，“fog services”（即混合分散服務）通常需要供給雙方都在的市場， 交易所或註冊管理機構。
這些市場被分為鏈上、鏈下、混合服務、中心化、去中心化等。

#### 4.2.1	示例：連接到 TON Payments。
例如，如果想要使用 TON Payments（參見 5），第一步是找到 “lightning network” 的現有的一些傳輸節點（參見 5.2），並與它們建立支付通道。借助於 “encompassing” 覆蓋網路可以找到一些節點，該覆蓋網路應該包含所有傳輸閃電網路節點（參見 3.3.17）。 但目前尚不清楚這些節點是否願意創建新的支付通道。 因此，需要註冊表來讓準備創建新連結的節點發佈它們的聯繫資訊（例如它們的抽象地址）。

#### 4.2.2	TON Storage。
類似地，如果想要將檔上傳到 TON Storage，則必須找到一些願意簽署智慧合約的節點， 以綁定它們來保留該檔的副本（或者任何低於特定大小限制的檔）。 因此需要提供用於存儲檔的服務節點的註冊表。

#### 4.2.3	鏈上，混合和鏈下註冊管理機構。
這樣的服務提供者註冊表可以完全在鏈上實現，借助智慧合約將註冊表保留在其永久存儲中。然而這將極其緩慢且昂貴。混合方法則更為有效，其中相對較小且很少更改的鏈上註冊表僅用於指出某些節點（通過其抽象地址或其公開金鑰，可用於定位實際的抽象地址，如  3.2.12），提供鏈下（中心化）註冊服務。
最後，分散的純粹的鏈下方法可能包括公共覆蓋網路（參見 3.3），那些願意提供服務的人， 或那些想要購買服務的人，只需通過他們的私密金鑰廣播他們的邀約。如果要提供的服務非常簡單
，甚至可能不需要廣播要約：覆蓋網路本身的近似成員資格可以用作願意提供特定服務的人的“註冊表”。如果已知的節點尚未準備好滿足其需求，需要此服務的用戶端可能會定位（參見3.3.7）並查詢此覆蓋網路的某些節點，然後查詢其鄰近節點。

#### 4.2.4	在一個側鏈上的註冊或交易。
實施分散式混合註冊管理機構的另一種方法是創建一個獨立的專業區塊鏈（“側鏈”），由其自己的一套驗證人維護，他們在鏈上智慧合約中發佈其身份並提供網路訪問對這個垂直區塊鏈的所有感興趣的各方，通過專用的覆蓋網路收集交易候選人和廣播區塊更新（參見 3.3）。 然後
，此側鏈的任何完整節點都可以維護自己的共用註冊表副本（基本上等於此側鏈的全域狀態）
，並處理與此註冊表相關的任意查詢。

#### 4.2.5	工作鏈中的註冊表或交易。
另一種選擇是在 TON Blockchain 內創建專用工作鏈，專門用於創建註冊管理機、市場和交易所。 與使用基本工作鏈中的智慧合約相比，這可能更有效，更便宜（參見 2.1.11）。 但是， 這仍然比在側鏈中維護註冊管理機構更昂貴（參見 4.2.4）。

### 4.3	訪問 TON Services
 
我們在 4.1 中討論了可能用於創建駐留在 TON 生態系統中的新服務和應用程式的不同方法。現在我們討論如何訪問這些服務，以及 TON 將提供的一些 “helper services”，包括 TON DNS 和 TON 存儲。

#### 4.3.1	TON DNS：主要是鏈上分層功能變數名稱服務。
TON DNS 是一種預定義的服務，它使用一組智慧合約來保存從人類可讀功能變數名稱到 ADNL 網路節點（T6 區塊鏈帳戶和智能合約）的（256 位）位址的映射。
雖然任何人原則上可以使用 TON Blockchain來實現這樣的服務，但是當應用程式或服務想要將人類可讀識別字轉換為位址時，預設情況下使用這種具有眾所周知的介面的預定義服務是有用的。

#### 4.3.2	TON DNS 用例。
例如，希望將一些加密貨幣轉移給另一個用戶或商家的用戶，可能更願意記住該用戶或商家的帳戶的 TON DNS 功能變數名稱，而不是複製黏貼他們的 256 位帳戶識別字到輕錢包用戶端的接收者欄位。
類似地，TON DNS 可用于定位智能合約的帳戶識別字或 ton-services 和 ton-sites 的入口點
（參見 4.1.5），從而啟用專用用戶端（“ton-browser”）或通常的互聯網流覽器 結合專門的
TON Proxy 擴展或獨立應用程式，為使用者提供類似 WWW 的流覽體驗。

#### 4.3.3	TON DNS 智能合約。
TON DNS 通過特殊（DNS）智慧合約樹實現。 每個 DNS 智慧合約都負責註冊某些固定域的子域。 將保留 TON DNS 系統的第一級域的 “根”DNS 智能合約位於主鏈中。 其帳戶識別字必須硬編碼到希望直接訪問 TON DNS 資料庫的所有軟體中。
任何 DNS 智慧合約都包含一個雜湊圖，將可變長度的以 null 結尾的 UTF-8 字串映射到它們的 “值” 中。 此雜湊圖實現為二進位 Patricia 樹，類似於 2.3.7 中描述的，但支持可變長度位串作為鍵。

#### 4.3.4	DNS 雜湊圖或 TON DNS 記錄的值。
至於這些值，它們是由 TL 方案描述的 “TON DNS 記錄”（參見 2.2.5）。它們由一個 “magic number” 組成，選擇一個支援的選項，然後選擇一個帳戶識別字，或一個智慧合約識別字，或一個抽象網路位址（參見 3.1），或一個用於定位抽象位址的公開金鑰服務（參見 3.2.12），或覆蓋網路的描述等等。一個重要的案例是另一個 DNS 智慧合約：在這種情況下，該智慧合約用於解析其域的子域。通過這種方式，可以為不同的域創建單獨的註冊表，由這些域的所有者控制。
這些記錄還可能包含到期時間，緩存時間（通常非常大，因為更新區塊鏈中的值通常是昂貴 的），並且在大多數情況下是對相關子域所有者的引用。所有者有權更改此記錄（特別是所有者欄位，從而將功能變數名稱轉移給其他人的控制權），並延長它。

#### 4.3.5	註冊現有域的新子域。
為了註冊現有域的新子域，人們只需向智慧合約發送消息，智慧合約是該域的註冊商，包含要註冊的子域（即金鑰），其中一個是預定義的值之一——由功能變數名稱所有者確定的罰款格式、所有者身份、到期日期和一定數量的加密貨幣。
子功能變數名稱以 “先到先得” 的方式註冊。
 
#### 4.3.6	DNS 智慧合約中檢索資料。
原則上，如果永久存儲內的雜湊值的結構和位置是智慧合約，那麼包含 DNS 智慧合約的主鏈或分片鏈的任何完整節點都可以查找該智慧合約的資料庫中的任何子域。
但這種方法僅適用于某些 DNS 智慧合約。 如果使用非標準 DNS 智慧合約它將會失敗。
相反，使用基於通用智慧合約介面和獲取方法的方法（參見 4.3.11）。 任何 DNS 智慧合約都必須定義帶有 “get method” 的 “known signature”，該方法被調用以查找金鑰。 由於這種方法對其他智慧合約也有意義，特別是那些提供鏈上和混合服務的合同，我們將在 4.3.11 中詳細解釋。

#### 4.3.7	TON DNS 域。
一旦任何全節點（單獨或代表某個輕用戶端）可以查找任何 DNS 智慧合約的資料庫中的條目
，就可以從熟悉的的固定根DNS智慧合約（帳戶）識別字開始，任意地翻譯任意 TON DNS
功能變數名稱。
例如，如果想要翻譯 A.B.C，就可以在根域資料庫中查找key .C，.B.C 和 A.B.C。 如果找不到第一個，但第二個找到了，並且其值是對另一個 DNS 智慧合約的引用，則在該智慧合約的資料庫中查找 A 並檢索最終值。

#### 4.3.8	為輕節點翻譯 TON DNS 功能變數名稱。
通過這種方式，主鏈的全節點以及功能變數名稱查找過程中涉及的所有分片鏈可以在沒有外部説明的情況下將任何功能變數名稱轉換為其當前值。 輕節點可以請求完整節點代表它執行此操作並返回該值以及 Merkle 證明（參見 2.5.11）。 這種 Merkle 證明將使得工作節點能夠驗證答案是否正確， 因此與通常的 DNS 協議相比，這種 TON DNS 回應不能被惡意攔截器 “spoofed”。
因為沒有節點可以預期是關於所有 shard 鏈的全節點，所以實際的 TON DNS 域轉換將涉及
這兩種策略的組合。

#### 4.3.9	專用的 “TON DNS servers”。
簡單的 “TON DNS servers”可以被提供，其將接收 RPC“DNS” 查詢（例如，通過 3.1 中描述的 ADNL 或 RLDP 協議），請求伺服器一個給定功能變數名稱，通過轉發一些來處理這些查詢必要時子查詢到其他（全）節點，並返回原始查詢的答案，如果需要，可以通過 Merkle 證明進行擴充。
這樣的 “DNS 伺服器” 可以使用 4.2 中描述的方法之一向任何其他節點，尤其是輕用戶端提供其服務（免費或收費）。 請注意，如果這些伺服器被認為是 TON DNS servers 的一部分，它將有效地將其從分散式鏈上服務轉換為分散式混合服務（即 “fog service”）。
以上是對 TON DNS 服務的簡要概述，TON DNS 服務是 TON Blockchain和 TON Network 實
體的人類可讀功能變數名稱的可擴展鏈式註冊表。

#### 4.3.10	訪問智慧合約中保存的資料。
我們已經看到，有時需要訪問存儲在智慧合約中的資料而不改變其狀態。
如果知道智慧合約實施的細節，就可以從智慧合約的永久性存儲中提取所有需要的資訊，這些資訊可供智慧合約所在的分片鏈的所有全節點使用。但是這是一種非常不優雅的方式，很大程度上取決於智慧合約的執行。
 
#### 4.3.11	“Get methods”。
更好的方法是在智慧合約中定義一些 get method，即某些分片的入站消息在交付時不會影響智慧合約的狀態，但會生成一個或多個包含 “result” 的輸出消息。以這種方式，可以在僅知道智慧合約實現具有已知簽名的 get method（即，要發送的入站消息的已知格式和作為結果要接收的出站消息）時從智慧合約獲得資料。
符合物件導向的程式設計（OOP）的方式更加優雅。但是到目前為止它有一個明顯的缺陷：執行時必須實際將交易提交到區塊鏈中（將獲取消息發送到智慧合約），等待它由驗證人提交和處理，從新的區塊中提取答案，並且支付 gas（即用於在驗證人的硬體上執行 “Get methods”
）。這是一種資源浪費：“Get methods”不會改變智慧合約的狀態，因此不需要在區塊鏈中執
行。

#### 4.3.12	智能合約“Get methods”的嘗試性執行。
我們已經談論過（參見 2.4.6）任何全節點都可以暫時執行任何智慧合約的任何方法（即向智慧合約發送任何消息），從智慧合約的給定狀態開始，而不實際提交相應的交易。全節點可以簡單地將所考慮的智慧合約的代碼載入到 TON VM 中，從分片鏈的全域狀態（分片鏈的所有全節點都知悉）初始化其永久存儲，並執行智慧合約代碼。入站消息作為其輸入參數。創建的輸出消息將產生此計算的結果。
這樣，任何全節點都可以評估任意智慧合約的任意get methods，前提是它們的簽名（即入站和出站消息的格式）是已知的。節點可以追蹤在該評估期間訪問的分片鏈狀態的細胞，並創建所執行的計算的有效性的 Merkle 證明，以獲得可能已經要求整個節點這樣做的工作節點（參見 2.5.11）。

#### 4.3.13	TL-schemes中的智慧合約介面。
回想一下，智慧合約實現的方法（即它接受的輸入消息）本質上是一些 TL 序列化的物件，可以通過 TL-schemes來描述（參見 2.2.5）。 得到的輸出消息也可以用相同的TL-schemes描述。 通過這種方式，智慧合約提供給其他帳戶和智慧合約的介面可以通過TL-schemes形式化。
特別是，智慧合約支持的 Get methods（的一部分）可以通過這種形式化的智慧合約介面來描述。

#### 4.3.14	智慧合約的公共介面。
請注意，形式化的智慧合約介面，無論是 TL-schemes（表示為 TL 原始檔案；參見 2.2.5）還是序列化形式都可以發佈——例如，在特殊領域中 智慧合約帳戶描述，存儲在區塊鏈中，或單獨存儲，如果此介面將被多次引用。 在後一種情況下，支援的公共介面的雜湊可以合併到智慧合約描述中而不是介面描述本身。
這種公共介面的一個例子是 DNS 智慧合約，它應該實現至少一種用於查找子域的標準 Get methods（參見 4.3.6）。 註冊新子域的標準方法也可以包含在 DNS 智慧合約的標準公共介面中。

#### 4.3.15	智慧合約的使用者介面。
智慧合約的公共介面的存在也有其他優點。例如，錢包用戶端應用程式可以在根據使用者的請求
檢查智慧合約時下載這樣的介面，並顯示智慧合約支援的公共方法列表（即可用動作的列表）
，可能具有一些在正式版本中提供的人類可讀的評論。
 
在使用者選擇這些方法之一之後，可以根據 TL-scheme自動生成表單，其中將提示用戶所選方法所需的所有欄位以及所需的加密貨幣量（例如 Grams）附在此請求上。提交此表單將創建一個新的區塊鏈交易，其中包含剛剛撰寫的消息，該消息來自使用者的區塊鏈帳戶。
通過這種方式，只要這些智慧合約已經發佈了他們的介面，使用者就可以通過填寫和提交某些表格，以使用者友好的方式與錢包用戶端應用程式中的任意智慧合約進行交互。

#### 4.3.16	ton-service 的使用者介面。
事實證明 “ton-services”（即駐留在 TON Network 中的服務以及通過 ADNL 和 RLDP 協議接受 3 的查詢；參見 4.1.5）也可能從 TL-scheme描述的公共介面中獲益（ 參見 2.2.5）。
用戶端應用程式（例如輕型錢包或 “ton-browser”）可能會提示用戶選擇其中一種方法，並使用介面定義的參數填寫表單，類似於剛剛在 4.3.15 中討論的內容。唯一的區別是生成的
TL-serialized 消息不作為區塊鏈中的交易提交；相反它作為 RPC 查詢被發送到所討論的“ton-service” 的抽象位址，並且根據形式介面（即 TL-scheme）解析和顯示對該查詢的回應。

#### 4.3.17	TON DNS 定位使用者介面。
包含 ton 服務的抽象位址或智慧合約帳戶識別字的 TON DNS 記錄還可以包含描述該實體的公共（使用者）介面的可選欄位，或者幾個支援的介面。 然後用戶端應用程式（無論是 wallet， ton-browser 還是 ton-proxy）將能夠以統一的方式下載介面並與相關實體（無論是智慧合約還是一個 ton-service）進行交互。

#### 4.3.18	模糊鏈上和鏈下服務之間的區別。
通過這種方式，最終使用者模糊了鏈上、鏈下和混合服務（參見 4.1.2）之間的區別：她只需將所需服務的功能變數名稱輸入到她的ton-browser的位址行或錢包中，其餘部分將由用戶端應用程式無縫處理。

 
#### 4.3.19	
 
TON entity explorer
 
Telegram
 
Messenger 用戶端中。
在這一點上出現了一個有趣的機會。 實現上述功能的輕型錢包和 TON 實體流覽器可以嵌入到Telegram Messenger 智慧手機用戶端應用程式中，從而將該技術帶給超過 2 億人。使用者可以通過在消息中包含 TON URIs（參見 4.3.22）來向 TON 實體和資源發送超連結； 如果選擇了這樣的超連結，將由接收方的電報用戶端應用程式在內部打開，並且將開始與所選實體的交互。

 
#### 4.3.20	“ton-sites”
 
HTTP
 
ton-services。
 
ton-site 只是一個支援 HTTP 介面的服務，可能還有其他一些介面。可以在相應的 TON DNS 記錄中宣佈該支援。

#### 4.3.21	超連結（Hyperlinks）。
請注意，ton-sites 返回的 HTML 頁面可能包含 ton-hyperlinks-即通過特製 URIs 方案引用其他ton-sites，智慧合約和帳戶參見 4.3.22）——包含摘要網路位址、帳戶識別字或人類可讀的TON DNS 功能變數名稱。 然後，當用戶選擇它時，“ton-browser” 可能會跟隨這樣的超連結，檢測要使用的介面，並顯示 4.3.15 和 4.3.16 中概述的使用者介面表格。
 
#### 4.3.22	URL 可以指定一些參數。
超連結 URL 不僅可以包含（TON）DNS 域或所討論的服務的抽象位址，還可以包含要調用的方法的名稱以及其部分或全部參數。可能的 URI 方案可能如下所示：

ton://<domain>/<method>?<field1>=<value1>&<field2>=. . .

當使用者在 ton-browser 中選擇這樣的連結時，該動作是立即形成（特別是如果它是智慧合約的獲取方法，匿名調用），或顯示部分填寫的表格，由使用者明確確認和提交（這可能是付款表格所必需的）。

#### 4.3.23	POST 動作。
一個 ton-sites 可以嵌入到 HTML 頁面中，它返回一些看似常見的 POST 表單，POST 操作通過合適的（TON）URL 引用 ton-sites，ton-services 或智能合約。 在這種情況下，一旦使用者填寫並提交該自訂表單，就會立即或在明確確認後採取相應的操作。

#### 4.3.24	TON WWW。
以上內容將説明創建整個網路的交叉引用實體，駐留在 TON Network中，最終用戶可通過噸流覽器訪問該網路，從而為使用者提供類似 WWW 的流覽體驗。 對於最終用戶，這最終將使區塊鏈應用程式與他們已經習慣的網站基本相似。

#### 4.3.25	TON WWW 的優點。
這種 “鏈上和鏈下” 服務的 “TON WWW” 與傳統服務相比具有一些優勢。 例如，支付本質上被集成在系統中。 使用者的身份可以始終呈現給服務（通過在交易和生成的 RPC 請求上自動生成的簽名）或隨意隱藏。  服務無需檢查和重新檢查用戶憑據；這些憑證可以一次性發佈在區塊鏈中。使用者網路匿名可以通過 TON 代理輕鬆保存，並且所有服務都將是有效且不可阻止的。小額支付也很容易，因為 ton-browser 可以與 TON 支付系統集成。


#### 5	TON Payments
我們將在本文TON 項目的最後一部分簡要討論TON Payments，這是（小額）支付通道和“閃電網路”價值轉移的平臺。它將實現“即時”支付，無需將所有交易提交到區塊鏈中、支付相關的交易費用（例如消耗的 gas）並等待五秒鐘、直到確認包含有關交易的區塊。
這種即時支付的總體開銷很小，可以將它們用於小額支付。例如，TON file-storing 服務可能會為每下載 128 KiB向用戶收費，或者付費 TON 代理可能需要為轉發的每128 KiB提供一些小額微支付。
雖然 TON Payments 可能會晚於 TON 專案核心部分的發佈，但一開始就需要考慮這些因
素。例如，用於執行 TON區塊鏈智能合約代碼的 TON 虛擬機器（TON VM；參見 2.1.20）必須
支持默克爾校驗的一些特殊操作。如果最初的設計中不存在此類支持，在之後的階段添加則可
 
能會出現問題（參見 2.8.16）。但是，我們將看到 TON虛擬機器天然支持“智慧”支付通道（參
見 5.1.9）。

### 5.1 支付通道
我們首先討論點對點支付通道，以及如何在 TON 區塊鏈中實施這些通道。

#### 5.1.1 支付通道的思路

假設 A 和 B 兩方都知道他們將來需要相互支付很多款項。他們不用將每筆付款提交到區塊鏈中交易，而是創建一個共用的“資金池”（或者也可能是一個只有兩個帳戶的小型私人銀行）， 並為其提供一些資金：A 貢獻 a 幣，B 貢獻 b 幣。這是通過在區塊鏈中創建一個特殊的智慧合約並將資金發送給智慧合約來實現的。
在創建“資金池”之前，雙方同意某個協議。他們將追蹤池的狀態——即共用池中的餘額。最初
，狀態是（a，b），意思是a幣實際上屬於 A，b 幣屬於 B。然後，如果 A 想要向 B 支付d幣
，他們可以簡單地同意新狀態是（a '，b'）=（a - d，b + d）。之後，如果 B 想要向 A 支付d'
幣，那麼狀態將成為（a''，b''）=（a'+ d'，b' - d'），依此類推。

所有這些池內餘額的更新都完全在鏈下完成。當雙方決定從池中取出應付資金時，他們會根據池的最終狀態進行操作。這是通過向智慧合約發送特殊消息來實現的，其中包含商定的最終狀態（a *，b *）以及 A 和 B 的簽名。然後智慧合約向 A發送a *幣，向B發送b *幣，並扣除自己的部分。

此智慧合約、以及 A 和 B 用於更新池子狀態的網路通訊協定是 A 和 B 之間的簡單支付通道。根據
4.1.2 中描述的分類，它是一種混合服務：其部分狀態存在于區塊鏈（智慧合約）中，但其大多數狀態更新都是鏈下（通過網路通訊協定）執行的。如果一切順利，雙方將能夠按照自己的意願執行盡可能多的付款（唯一的限制是通道的容量不會超支——即，他們在付款通道中的餘額都大於0），只要將兩個交易提交到區塊鏈中：一個用於打開（創建）支付通道（智慧合約）， 另一個用於關閉（銷毀）通道。

#### 5.1.2 無需信任的支付通道

前面的例子有點不切實際，因為它假設雙方都願意合作，絕不會用欺騙的手段獲得一些好處。想像一下，假如A  在a'<a的情況下，會選擇不簽署最終出餘額（a'，b'）。這將使 B  陷入困境。

為防止這種情況，人們通常會嘗試開發無需信任的支付通道協定，這些協定不要求各方相互信任，並規定懲罰任何試圖作弊的人。
這通常借助簽名來實現。支付通道智慧合約知道 A 和 B 的公開金鑰，並且如有必要，可以檢查他 們的簽名。支付通道協定要求各方簽署中間狀態並將簽名發送給彼此。然後，如果其中一方欺騙——例如假裝支付通道的某些狀態從未存在——可以通過在該狀態上顯示其簽名來證明其不當行為。支付通道智慧合約充當“鏈上仲裁者”，能夠處理雙方關於彼此的投訴，並通過沒收所有資金並將其授予另一方來懲罰作惡方。
 
#### 5.1.3 簡單、雙向同步的無需信任支付通道

考慮以下更實際的例子：支付通道的狀態由三元組（δi, i, oi ）描述，其中 i 是狀態的序號
（原始數值是零，隨後出現一個狀態，數值增加1），δi 是通道不平衡（意味著 A 和 B 分別擁有 a+δi 和 b − δi 幣），並且 oi 是允許產生下一狀態（A 或 B）的一方。 在取得進一步進展之前，每個狀態必須由 A 和 B 簽署。

現在，如果 A 想要將 d 幣轉移到支付通道內的 B，並且當前狀態是 Si = (δi, i, oi) ，其中 oi = A
，則它只是創建一個新狀態 Si+1 = (δi − d, i + 1, oi+1) ，簽名，並將其連同其簽名一起發送給B。然後 B 通過簽名並將其簽名副本發送給 A 來確認。之後，雙方都擁有含新簽名的新狀態的副本，並且可能會有新的轉帳。

如果 A 想要在具有 oi = B的Si狀態中將幣轉到 B，則它首先要求 B 提交Si+1的後續狀態，具有相同不平衡δi+1 = δi，但是oi+1 = A 。之後，A 將能夠進行轉帳。
當雙方同意關閉支付通道時，他們都將他們的特殊最終簽名放在他們認為是最終的狀態 Sk 上
，並通過發送最終狀態和最終簽名來調用支付通道智慧合約的最終或雙方最終確定的方法。

如果另一方不同意提供其最終簽名，或者僅僅是停止回應，則可以單方面關閉該通道。為此， 想這麼做的一方將調用單方面的最終確定方法，向智慧合約發送其最終狀態的版本、最終簽名以及具有另一方簽名的最新狀態。在此之後，智慧合約不會立即對收到的最終狀態採取行動。相反，它會等待一段時間（例如，一天）以使另一方呈現其最終狀態的版本。當另一方提交其版本並且結果與已提交的版本相容時，“真實”的最終狀態由智慧合約計算並相應地分配資金。如果另一方未能將其最終狀態的版本呈現給智慧合約，則根據所呈現的最終狀態的唯一副本重新分配資金。
如果雙方中有一方作弊——例如，簽署兩個不同的作為最終狀態，或者簽署兩個不同的下一狀態 Si+1 和 S' i+1，或者簽署無效的新狀態 Si+1 （例如，不平衡狀態δi+1 <-a 或> b）——則另一方可以提交這種不當行為的證明到智慧合約的第三種方法。作惡的一方將立即受到懲罰，完全失去其在支付通道中的份額。

這種簡單的支付通道協議是公平的，即無論是否有另一方的合作，任何一方都可以隨時獲得應
付款，並且如果它試圖作弊，可能會失去提交到支付通道的所有資金。

#### 5.1.4	同步支付通道，一個帶有兩個驗證人的簡單的虛擬區塊鏈
以上簡單、同步支付通道的示例可以按以下操作重新製作。想像一下，狀態序列 S0, S1, ..., Sn
實際上是非常簡單的區塊鏈的區塊序列。該區塊鏈的每個區塊基本上僅包含區塊鏈的當前狀態
，並且可能是對前一個區塊的引用（即，其雜湊值）。A 和 B 雙方都充當此區塊鏈的驗證人
，因此每個區塊必須收集其兩個簽名。區塊鏈的狀態 Si 定義為下一個區塊的指定生產者 oi， 因此 A 和 B 之間沒有生成下一個區塊的競爭。出塊節點 A 可創建區塊，將資金從 A 轉移到 B
（即，減少不平衡：δi+1 ≤ δi) ，並且 B 只能將資金從 B 轉移到 A（即，增加δ）。
如果兩個驗證人就區塊鏈的最終區塊（和最終狀態）達成一致，則通過收集雙方的特殊“最終” 簽名來最終確定，並將其與最終區塊一起提交給通道智慧合約進行處理和相應地重新分配資金。
 
如果驗證人簽署了無效區塊，或者創建了一個分叉，或者簽署了兩個不同的最終區塊，則可以通過向智慧合約提供其不當行為的證據來懲罰它，該合同充當兩個驗證人的“鏈上仲裁者”；然後，違方將失去保留在支付通道中的所有資金，這類似於失去其 stake 的驗證人。

#### 5.1.5	非同步支付通道，具有兩個工作鏈的虛擬區塊鏈
5.1.3 中討論的同步支付通道具有一定缺陷：在另一方沒有確認之前的交易之前，不能開始下一筆交易（支付通道內的匯款）。這可以通過用兩個交互虛擬工作鏈（或者說是分片鏈）的系統替換 5.1.4 中討論的單鏈虛擬區塊鏈來解決。
這些工作鏈中的第一條僅包含 A 的事務，區塊只能由 A 生成；它的狀態是 Si = (i, φi, j, ψj ), 其中 i 是區塊序號（即到目前為止由 A 執行的交易或匯款的數量），φi 是目前為止從 A 轉移到B 的總量，j 是 A 知道的 B 區塊鏈中最近有效區塊的序號，ψj 是其 j 交易中從 B 轉移到 A 的金額。放在第 j 個塊上的 B 的簽名也應該是這個狀態的一部分。也可以包括該工作鏈的前一個塊和另一個工作鏈的第 j 個塊的雜湊。如果 i > 0, ψj ≥ 0 且-a≤ψj−φi≤b，Si的有效性條件包括φi ≥ 0, φi ≥ φi−1。
類似地，第二個工作鏈僅包含 B 的交易，區塊僅由 B 生成；其狀態為 Tj = (j, ψj , i, φi) ，具有相似的有效性條件。

現在，如果 A 想要將一些錢轉移到 B，它只需在其工作鏈中創建一個新塊，簽名併發送給 B
，無需等待確認。

支付通道由 A 簽署（其版本）區塊鏈的最終狀態（具有特殊的“最終簽名”），B 簽署其區塊鏈的最終狀態，並將這兩個最終狀態呈現給支付通道智慧合約的最終確定方法。單方最終確定也是可能的，但在這種情況下，智慧合約必須等待另一方提交其最終狀態的版本，至少需要一定寬限期。

#### 5.1.6 單向支付通道

如果只有 A 需要向 B 付款（例如，B 是服務提供者，A 是其客戶），則可以創建單邊支付通道。從本質上講，它只是 5.1.5 中描述的沒有第二條工作鏈的第一條工作鏈。相反，可以說
5.1.5 中描述的非同步支付通道由兩個單向支付通道組成，或由同一智慧合約管理的“半通道”組
成。

#### 5.1.7 更複雜的支付通道，授權

我們將在後面的 5.2.4 中看到，“閃電網路”（參見 5.2），通過幾個支付通道的鏈實現即時匯
款，需要所涉及的支付通道更加複雜。

特別是，我們希望能夠提交“授權”或“有條件轉帳”：A 同意向 B 發送 c 幣，但 B 只有在滿足某個條件時才會獲得資金（例如，B 可以用一個已知的 v 值表示Hash(u) = v）。否則，A 可以在一段時間後收回資金。
這樣的授權可以通過簡單的智慧合約在鏈上輕鬆實現。我們希望授權和其他類型的有條件轉帳可以在鏈下支付通道中進行，因為它們可以大大簡化“閃電網路”中存在的支付通道鏈上的資金轉移（參見 5.2.4）。
 
5.1.4 和 5.1.5 中概述的“支付通道，簡單的區塊鏈”方案在這裡變得很方便。現在我們考慮一個更複雜的虛擬區塊鏈，其狀態包含一系列未實現的“授權”，以及鎖定在此類授權中的資金數 量。這個區塊鏈——或非同步情況下的兩個工作鏈——必須通過它們的雜湊明確引用之前的區塊。不過，整個機制仍然相同。

#### 5.1.8	複雜的支付通道智慧合約面臨的挑戰
請注意，雖然複雜的支付通道的最終狀態仍然很小，而且最終確定很簡單（如果雙方已就其應付金額達成一致，並且雙方已簽署協議，就無需做其他事），但單邊確定方法和懲罰欺詐行為的方法需要更加複雜。實際上，他們必須能夠接受默克爾校驗不正當行為，並檢查支付通道鏈上更複雜的交易是否在正確處理。
換句話說，支付通道智慧合約必須能夠使用默克爾校驗，檢查其“雜湊有效性”，並且必須包含支付通道（虛擬）鏈的 evtrans 和 evblock 功能的實現（參見 2.2.6）。

#### 5.1.9	TON VM	“智能”

用於運行 TON區塊鏈智慧合約代碼的 TON VM 可以應對執行“智慧”或複雜支付通道所需的智慧合約（參見 5.1.8）。
在這一點上，“everything is a bag of cells” 範例（參見 2.5.14）變得非常方便。由於所有塊
（包括臨時支付通道區塊鏈的塊）都表示為a bag of cells（並由一些代數資料分片描述），並且同樣適用於消息和默克爾校驗，因此可以輕鬆地將默克爾校驗嵌入到發送到支付通道智慧合約的入站消息。默克爾校驗的“雜湊條件”將會自動進行檢查，並且當智慧合約訪問所呈現的“默克爾校驗”時，它的使用方式就好像它是相應的代數資料分片的值——儘管不完整，樹的一些子樹被包含省略子樹的默克爾雜湊的特殊節點替換。然後，智慧合約將使用該值，該值可能代表支付通道（虛擬）區塊鏈的塊及其狀態，並將評估該區塊的區塊鏈的 ev_block 功能（參見2.2.6）和以前的狀態。然後，計算結束，並且可以將最終狀態與區塊中斷言的狀態進行比較
，或者在嘗試訪問缺席子樹時拋出“缺席節點”異常，表明默克爾校驗無效。

通過這種方式，使用 TON 區塊鏈智慧合約實現智慧支付通道區塊鏈的驗證碼變得非常簡單。有人可能會說，TON 虛擬機具有內置支援，可以檢查其他簡單區塊鏈的有效性。唯一的限制因素是要合併到智慧合約（即進入交易）的入站消息中默克爾校驗的大小。

#### 5.1.10	智慧支付通道內的簡單支付通道

我們想討論在現有支付通道內創建簡單（同步或非同步）支付通道的可能性。

雖然這看起來有點令人費解，但理解和實施並不比 5.1.7 中討論的“授權”困難得多。基本上， 如果出現一些雜湊問題的解決方案，並不是承諾向另一方支付 c 幣，A 承諾根據某些其他（虛擬）支付通道區塊鏈的最終結算向 B 支付最多 c 幣。一般來說，這個其他支付通道區塊鏈甚至不需要在 A 和 B 之間；它可能涉及其他方，比如 C 和 D 將分別提交 c 和 d 幣至其簡單的支付通道。（這種可能性在後面的 5.2.5 中使用。）
如果包含的支付通道是不對稱的，則需要將兩個授權提交到兩個工作鏈中：如果“內部”簡單支付通道的最終結算產生負的最終不平衡δ且 0≤-δ≤c，A 將承諾向 B 支付-δ個幣；如果δ為正， 則 B 必須承諾向 A 支付δ。另一方面，如果包含支付通道是對稱的，這可以通過由A將單個含
 
參數（c，d）的“簡單支付通道創建”交易一起提交到單個支付通道區塊鏈中來完成（這將凍結屬於A的 c 幣），然後由 B 進行特殊的“確認交易”（這將凍結 B 的d幣）。
我們希望內部支付通道非常簡單（例如，5.1.3 中討論的簡單同步支付通道），以使要提交的默克爾校驗的大小最小化。在上，外部支付通道必須是5.1.7 意義上的“智慧”。

### 5.2	“閃電網路”

現在我們討論 TON Payments 的“閃電網路”，它可以實現任意兩個參與節點間的即時轉帳。

#### 5.2.1 支付通道的限制

支付通道對於期望在他們之間進行大量轉帳的各方非常有用。但是如果只需向特定收款方轉帳一次或兩次，那麼與她創建支付通道將是不切實際的。除此之外，這意味著凍結支付通道中的大量資金，並且無論如何都需要至少兩個區塊鏈交易。

#### 5.2.2	支付通道 或 “閃電網路”

支付通道網路通過支付通道鏈實現轉帳，克服了支付通道的缺陷。如果 A 希望將資金轉移到E，她不需要與 E 建立支付通道。通過幾個中間節點（例如，四個支付通道，從 A 到 B，從 B 到 C，從 C 到 D，從 D 到 E）連接 A 和 E 的支付通道就足夠了。.

#### 5.2.3 支付通道網路概述

回想一下，支付通道網路，也稱為 “閃電網路”，由一組參與節點組成，其中一些節點已在它們之間建立了長期支付通道。我們將看到這些支付通道必須是 5.1.7 意義上的“智慧”。 當參與節點 A 想要將錢轉移到任何其他參與節點 E 時，她試圖找到在支付通道網路內連接 A 到 E 的路徑。當找到這樣的路徑時，她沿著這條路徑進行 “區塊鏈資金轉帳”。

#### 5.2.4 區塊鏈資金轉帳
假設存在從 A 到 B，從 B 到 C，從 C 到 D，從 D 到 E 的支付通道鏈。此外，假設 A 想要將
x 個代幣轉移到 E。

一種簡單的方法是沿著現有的支付通道將 x 個代幣轉移到 B，並要求他將錢進一步轉發給 C。但是，為什麼 B  不自己拿錢呢？因此，必須採用更複雜的方法，無需要求所有相關方相互信任。

這可以通過以下方式實現。A 生成一個大的亂數 u 並計算其雜湊 v = Hash（u）。然後她創建一個授權，如果有一個帶有雜湊 v 的數字 u（參見 5.1.7），在她的支付通道中有 B，則向B 支付 x個代幣。這個授權包含 v，但不是 u，u仍然保密。
之後，B 在其支付通道中創建了與 C 類似的授權。他並不害怕給出這樣的授權，因為他知道A 給他的類似授權的存在。如果 C 曾提出雜湊問題的解決方案來收取 B 承諾的 x 個代幣，那麼 B 將立即向 A 提出該方案，向 A 收取 x 個代幣。
 
然後創建 C 到 D 和 D 到 E 的類似授權。當授權全部到位時，A 通過將解決方案 u 傳達給所有相關方——或者只是向 E 傳達來觸發轉帳。
本文檔省略了一些細節。例如，這些授權必須具有不同的到期時間，並且授權的金額可能在鏈上略有不同（B 可能只承諾 x——ε個代幣給 C，其中ε是預先商定的小額轉帳費用）。我們暫時忽略這些細節，因為它們對於理解支付通道如何運作以及如何在 TON 中實施這些細節並不太重要。

#### 5.2.5 支付通道鏈中的虛擬支付通道

現在假設 A 和 E 期望相互間有很多的支付往來。他們可能會在他們之間的區塊鏈中創建一個新的支付通道，但這仍然非常昂貴，因為有些資金會被鎖定在這個支付通道中。另一種選擇是對每筆付款使用 5.2.4 中描述的區塊鏈資金轉帳。但是，這將涉及大量網路活動以及所涉及的所有支付通道的虛擬區塊鏈中的大量交易。
另一種方法是在支付通道網路中連接 A 到 E 的鏈內創建虛擬支付通道。為此，A 和 E 為他們的付款創建（虛擬）區塊鏈，就像他們要在區塊鏈中創建支付通道一樣。然而，他們不是在區塊鏈中創建支付通道智慧合約，而是要求所有中間支付通道——連接 A 到 B、B 到 C等等通道——在中間創建簡單的支付通道，綁定到 A 和E創建的虛擬區塊鏈（參見 5.1.10）。換句話說，現在根據 A 和 E 之間的最終結算轉移資金的授權存在於每個中間支付通道內。
如果虛擬支付通道是單向的，那麼這種授權可以很容易實現，因為最終的不平衡δ將是負數， 因此可以在中間支付通道內以與 5.2.4 中描述的相同的順序創建簡單的支付通道。它們的到期時間也可以以相同的方式設置。
如果虛擬支付通道是雙向的，情況會稍微複雜一些。在這種情況下，應該根據最終結算將轉移δ代幣的授權分為兩個半授權，如 5.1.10 所述：向前方向轉移δ− = max(0, −δ) 代幣，以及在向後方向上傳遞δ+ = max(0, δ) 。這些半授權可以在中間支付通道中獨立創建，一個從 A 到 E方向的半授權鏈，另一個相反方向的鏈。

#### 5.2.6 尋找閃電網路中的路徑

到目前為止，有一點仍然未被討論：A 和 E 將如何在支付網路中找到連接它們的路徑？如果支付網路不是太大，則可以使用類似 OSPF 的協定：支付網路的所有節點創建覆蓋網路（參見 3.3.17），然後每個節點傳播所有可用連接（即，參與支付通道）通過gossip協議向其鄰近節點提供資訊。最終，所有節點都將擁有參與支付網路的所有支付通道的完整列表，並且能夠自己找到最短路徑——例如，通過應用 Dijkstra 修改的演算法版本來考慮所涉及的支付通道的
“容量”（即，可以沿通道轉移的最大金額）。一旦找到候選路徑，就可以通過包含完整路徑的特殊 ADNL 資料包進行探測，並要求每個中間節點確認所討論的支付通道的存在，並根據該路徑進一步轉發該資料包。之後，可以構建鏈，以及用於鏈轉移或者在支付通道鏈中（參見5.2.4）創建虛擬支付通道的協議可以運行。

#### 5.2.7 優化

可以在此處進行一些優化。例如，只有閃電網路的傳輸節點需要參與 5.2.6 中討論的類似
OSPF 的協議。希望通過閃電網路連接的兩個“葉子”節點將彼此通信他們所連接的傳輸節點的
 
清單（即，他們已經建立了參與支付網路的支付通道）。然後，如上面 5.2.6 中所述，可以檢查從一個列表到另一個清單中的傳輸節點的路徑。

#### 5.2.8 結論
我們已經概述了TON項目的區塊鏈和網路技術如何足夠完成創建TON Payments（一個用於鏈下即時轉帳和小額支付的平臺）的任務。該平臺對於TON生態系統中的服務非常有用，使他們可以在有需要時輕鬆收取小額支付。

我們提出了一種可擴展的多區參見鏈架構，能夠支持大規模流行的加密貨幣和去中心化應用程式，帶有使用者友好的介面。
為了實現必要的可擴展性，我們提出了TON區塊鏈，一個“緊密耦合”的多區塊鏈系統（參2.8.14），採用自下而上的分片方法（參見2.8.12和2.1.2）。為了進一步提高潛在績效，我們引入了二維區塊鏈（2-blockchain）機制來替換無效區塊（參見2.1.17）和即時超立方體路由
（Instant Hypercube Routing），以實現分片之間更快速的交流（參見2.4.20）。將TON區塊鏈與現有和計畫中的區塊鏈專案（參見2.8和2.9）進行簡要比較，突出了TON這種方法的好處
，這是一個追求每秒處理數百萬次交易的系統。
第3章中描述的TON網路，涵蓋了計畫的多區塊鏈基礎設施的網路需求。該網路元件還可以與區塊鏈結合使用，以創建廣泛的應用和服務，單獨使用區塊鏈是不可能的（參見2.9.13）。第4章討論的這些服務包括TON DNS，這是一種將人類可讀物件識別碼轉換為其位址的服務; TON Storage，一個用於存儲任意檔的分散式平臺; TON Proxy，一種將網路訪問匿名化和訪問TON驅動服務的服務;TON Payments（參見第5章），一個跨TON生態系統、用於即時脫鏈資金轉移的平臺，應用程式可以使用這個生態系統進行小額支付。
TON基礎設施可以使用專門的輕用戶端錢包和“ton流覽器”的桌面和智慧手機app，為終端使用者提供類似流覽器的體驗（參見4.3.24），這使得在TON平臺上進行的加密貨幣支付、與智慧合約和其他服務的交互對大眾使用者可訪問。這樣的輕用戶端可以集成到Telegram Messenger用戶端（參見4.3.19），從而最終為數億用戶帶來了大量基於區塊鏈的應用程式。
 









[1]	K. Birman, Reliable Distributed Systems: Technologies, Web Services and Applications, Springer, 2005.
[2]	V. Buterin, Ethereum: A next-generation smart contract and de- centralized application platform, https://github.com/ethereum/wiki/wiki/White-Paper, 2013.
[3]	M. Ben-Or, B. Kelmer, T. Rabin, Asynchronous secure computa- tions with optimal resilience, in Proceedings of the thirteenth annual ACM symposium on Principles of distributed computing, p. 183–192. ACM, 1994.
[4]	M. Castro, B. Liskov, et al., Practical byzantine fault tolerance, Proceedings of the Third Symposium on Operating Systems Design and Implementation (1999), p. 173–186, available at http://pmg.csail.mit.edu/papers/osdi99.pdf.
[5]	EOS.IO, EOS.IO technical white paper, https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md, 2017.
[6]	D. Goldschlag, M. Reed, P. Syverson, Onion Routing for Anony- mous and Private Internet Connections, Communications of the ACM, 42, num. 2 (1999), http://www.onion-router.net/Publications/CACM-1999.pdf.
[7]	L. Lamport, R. Shostak, M. Pease, The byzantine generals problem, ACM Transactions on Programming Languages and Systems, 4/3 (1982), p. 382–401.
[8]	S. Larimer, The history of BitShares, https://docs.bitshares.org/bitshares/history.html, 2013.
[9]	M. Luby, A. Shokrollahi, et al., RaptorQ forward error correction scheme for object delivery, IETF RFC 6330, https://tools.ietf.org/html/rfc6330, 2011.
[10]	P. Maymounkov, D. Mazières, Kademlia: A peer-to-peer infor- mation system based on the XOR metric, in IPTPS ’01 revised pa- pers from the First International Workshop on Peer-to-Peer Systems, p. 53–65, available at http://pdos.csail.mit.edu/~petar/papers/ maymounkov-kademlia-lncs.pdf, 2002.
[11]	A. Miller, Yu Xia, et al., The honey badger of BFT protocols, Cryptology e-print archive 2016/99, https://eprint.iacr.org/2016/ 199.pdf, 2016.
[12]	S. Nakamoto, Bitcoin: A peer-to-peer electronic cash system, https://bitcoin.org/bitcoin.pdf, 2008.
[13]	S. Peyton Jones, Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine, Journal of Functional Pro- gramming 2 (2), p. 127–202, 1992.
[14]	A. Shokrollahi, M. Luby, Raptor Codes, IEEE Transactions on Information Theory 6, no. 3–4 (2006), p. 212–322.
[15]	M. van Steen, A. Tanenbaum, Distributed Systems, 3rd ed., 2017.
[16]	The Univalent Foundations Program, Homotopy Type Theory: Univalent Foundations of Mathematics, Institute for Advanced Study, 2013, available at https://homotopytypetheory.org/book. 
[17]	G. Wood, Polkadot: vision for a heterogeneous multi-chain frame- work, draft 1, https://github.com/w3f/polkadot-white-paper/raw/ master/PolkaDotPaper.pdf, 2016.




轉載或商用請保留作者與譯者的姓名。
新版白皮書未來將更新在 https://github.com/opeakt/TONBUS，請留意更新。
